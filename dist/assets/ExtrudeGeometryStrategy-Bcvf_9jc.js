import{S as p,P,E as S,i as C,b as E,c as I,M as W,I as f,V as w,d as y,j as G,k as L,Q as B,e as D,f as k,h as q,g as A}from"./main-DfJuPUUt.js";import{TrackGenerationStrategy as H}from"./TrackGenerationStrategies-CvPwYe8v.js";class F extends H{constructor(i){super(i),this.defaultConfig={steps:200,bevelEnabled:!1,closed:!0,crossSection:null,generatePhysics:!0,segmentLength:6,physicsSimplification:.5}}generate(i){const e={...this.defaultConfig,...i};if(!i.path)throw new Error("ExtrudeGeometryStrategy requires a path (THREE.Curve)");console.log("🏗️ Generating extruded track...");const t=e.crossSection||this.createDefaultCrossSection(e),n={meshes:[],bodies:[],startPosition:null,finishPosition:null,bounds:{minY:1/0,maxY:-1/0}},{mesh:s,geometry:o}=this.generateExtrudedTrack(t,i.path,e);if(n.meshes.push(s),this.scene.add(s),e.generateDecorations){const r=this.generateDecorations(i.path,e);n.meshes.push(...r),r.forEach(a=>this.scene.add(a))}if(e.generatePhysics){const r=this.generatePhysicsFromGeometry(o,i.path,e);n.bodies=r,r.forEach(a=>this.physicsWorld.addBody(a))}return this.calculateTrackBounds(i.path,n),console.log(`✅ Extruded track generated with ${e.steps} steps`),n}createDefaultCrossSection(i){const e=new p,t=i.width||10,n=i.wallHeight||1.5,s=i.wallThickness||.5,o=i.trackThickness||.6;return e.moveTo(-t/2-s,0),e.lineTo(-t/2-s,n),e.lineTo(-t/2,n),e.lineTo(-t/2,o),e.lineTo(-t/2+s,o),i.addGrooves&&(e.lineTo(-t/3,o),e.lineTo(-t/3,o-.05),e.lineTo(-t/3+.2,o-.05),e.lineTo(-t/3+.2,o),e.lineTo(-.2/2,o),e.lineTo(-.2/2,o-.05),e.lineTo(.2/2,o-.05),e.lineTo(.2/2,o),e.lineTo(t/3-.2,o),e.lineTo(t/3-.2,o-.05),e.lineTo(t/3,o-.05),e.lineTo(t/3,o)),e.lineTo(t/2-s,o),e.lineTo(t/2,o),e.lineTo(t/2,n),e.lineTo(t/2+s,n),e.lineTo(t/2+s,0),e.lineTo(-t/2-s,0),e}createTunnelCrossSection(i){const e=new p,t=i.width||10,n=i.height||8,s=i.thickness||1,o=n/2;e.moveTo(-t/2,0),e.lineTo(-t/2,n-o),e.quadraticCurveTo(-t/2,n,-t/2+o,n),e.lineTo(t/2-o,n),e.quadraticCurveTo(t/2,n,t/2,n-o),e.lineTo(t/2,0),e.lineTo(-t/2,0);const r=new P,a=t-s*2,c=n-s,l=c/2;return r.moveTo(-a/2,s),r.lineTo(-a/2,c-l),r.quadraticCurveTo(-a/2,c,-a/2+l,c),r.lineTo(a/2-l,c),r.quadraticCurveTo(a/2,c,a/2,c-l),r.lineTo(a/2,s),r.lineTo(-a/2,s),e.holes.push(r),e}createBridgeCrossSection(i){const e=new p,t=i.width||12,n=i.railHeight||1.2,s=i.railWidth||.3,o=i.deckThickness||.8;return e.moveTo(-t/2,0),e.lineTo(-t/2,n),e.lineTo(-t/2+s,n),e.lineTo(-t/2+s,o),e.lineTo(t/2-s,o),e.lineTo(t/2-s,n),e.lineTo(t/2,n),e.lineTo(t/2,0),e.lineTo(-t/2,0),e}generateExtrudedTrack(i,e,t){const n=this.generateRainbowColors(t.steps),s={steps:t.steps,bevelEnabled:t.bevelEnabled,extrudePath:e},o=new S(i,s),r=new Float32Array(o.attributes.position.count*3),a=o.attributes.position.array;for(let h=0;h<o.attributes.position.count;h++){const d=(a[h*3+2]+e.getLength()/2)/e.getLength(),g=Math.floor(d*n.length),T=n[Math.min(g,n.length-1)];r[h*3]=T.r,r[h*3+1]=T.g,r[h*3+2]=T.b}o.setAttribute("color",new C(r,3));const c=this.createTrackMaterial(),l=new E(o,c);return l.castShadow=!0,l.receiveShadow=!0,{mesh:l,geometry:o}}generateDecorations(i,e){const t=[];if(e.addDistanceMarkers){const s=i.getLength(),o=Math.floor(s/50),r=new I(.5,3,.5),a=new W({color:16711680,emissive:16711680,emissiveIntensity:.3}),c=new f(r,a,o*2);let l=0;for(let h=1;h<=o;h++){const u=h*50/s,d=i.getPoint(u),g=i.getTangent(u),T=new w(0,1,0),m=new w().crossVectors(g,T).normalize(),M=d.clone().add(m.clone().multiplyScalar(-7)),v=new y;v.setPosition(M),c.setMatrixAt(l++,v);const b=d.clone().add(m.clone().multiplyScalar(7)),x=new y;x.setPosition(b),c.setMatrixAt(l++,x)}c.instanceMatrix.needsUpdate=!0,t.push(c)}if(e.crossSectionType==="tunnel"&&e.addLights){const s=i.getLength(),o=Math.floor(s/20),r=new G(.3,8,8),a=new L({color:16776960,emissive:16776960}),c=new f(r,a,o);for(let l=0;l<o;l++){const h=l*20/s,u=i.getPoint(h);u.y+=e.height-1;const d=new y;d.setPosition(u),c.setMatrixAt(l,d)}c.instanceMatrix.needsUpdate=!0,t.push(c)}return t}generatePhysicsFromGeometry(i,e,t){const n=[],s=Math.ceil(e.getLength()/t.segmentLength);for(let o=0;o<s;o++){const r=o/s,a=Math.min((o+1)/s,1),c=e.getPoint(r),l=e.getPoint(a),h=c.clone().add(l).multiplyScalar(.5),u=c.distanceTo(l),d=e.getTangent((r+a)/2),g=new B().setFromUnitVectors(new w(0,0,1),d),T=new D(new k((t.width||10)/2,t.trackThickness||.6,u/2)),m=new q({mass:0,shape:T,position:new k(h.x,h.y,h.z),quaternion:new A(g.x,g.y,g.z,g.w),material:this.trackBuilder.materials.track});n.push(m)}return console.log(`⚙️ Created ${n.length} physics bodies for extruded track`),n}calculateTrackBounds(i,e){const t=i.getPoints(100);let n=1/0,s=-1/0;t.forEach(o=>{n=Math.min(n,o.y),s=Math.max(s,o.y)}),e.bounds.minY=n,e.bounds.maxY=s,e.startPosition=i.getPoint(0).clone(),e.startPosition.y+=2,e.finishPosition=i.getPoint(.95).clone()}}export{F as ExtrudeGeometryStrategy};
//# sourceMappingURL=ExtrudeGeometryStrategy-Bcvf_9jc.js.map
