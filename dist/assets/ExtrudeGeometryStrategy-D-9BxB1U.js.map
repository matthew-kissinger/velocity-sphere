{"version":3,"file":"ExtrudeGeometryStrategy-D-9BxB1U.js","sources":["../../src/tracks/generation/ExtrudeGeometryStrategy.js"],"sourcesContent":["/**\r\n * ExtrudeGeometryStrategy - Track generation using ExtrudeGeometry for complex cross-sections\r\n * \r\n * Creates racing tracks by extruding a 2D shape along a 3D path.\r\n * Features:\r\n * - Custom track cross-sections (tunnels, bridges, etc.)\r\n * - Built-in walls and barriers as part of the extrusion\r\n * - Support for complex track features\r\n */\r\n\r\nimport * as THREE from 'three';\r\nimport * as CANNON from 'cannon-es';\r\nimport { TrackGenerationStrategy } from './TrackGenerationStrategies.js';\r\n\r\nexport class ExtrudeGeometryStrategy extends TrackGenerationStrategy {\r\n  constructor(trackBuilder) {\r\n    super(trackBuilder);\r\n    this.defaultConfig = {\r\n      steps: 200,\r\n      bevelEnabled: false,\r\n      closed: true,\r\n      crossSection: null,\r\n      generatePhysics: true,\r\n      segmentLength: 6,\r\n      physicsSimplification: 0.5 // Reduce physics mesh complexity\r\n    };\r\n  }\r\n\r\n  generate(config) {\r\n    const finalConfig = { ...this.defaultConfig, ...config };\r\n    \r\n    if (!config.path) {\r\n      throw new Error('ExtrudeGeometryStrategy requires a path (THREE.Curve)');\r\n    }\r\n\r\n    console.log('ðŸ—ï¸ Generating extruded track...');\r\n\r\n    // Create or use provided cross-section shape\r\n    const shape = finalConfig.crossSection || this.createDefaultCrossSection(finalConfig);\r\n    \r\n    // Generate track data\r\n    const trackData = {\r\n      meshes: [],\r\n      bodies: [],\r\n      startPosition: null,\r\n      finishPosition: null,\r\n      bounds: { minY: Infinity, maxY: -Infinity }\r\n    };\r\n\r\n    // Generate extruded track\r\n    const { mesh, geometry } = this.generateExtrudedTrack(shape, config.path, finalConfig);\r\n    trackData.meshes.push(mesh);\r\n    this.scene.add(mesh);\r\n\r\n    // Generate decorative elements\r\n    if (finalConfig.generateDecorations) {\r\n      const decorations = this.generateDecorations(config.path, finalConfig);\r\n      trackData.meshes.push(...decorations);\r\n      decorations.forEach(deco => this.scene.add(deco));\r\n    }\r\n\r\n    // Generate physics\r\n    if (finalConfig.generatePhysics) {\r\n      const bodies = this.generatePhysicsFromGeometry(geometry, config.path, finalConfig);\r\n      trackData.bodies = bodies;\r\n      bodies.forEach(body => this.physicsWorld.addBody(body));\r\n    }\r\n\r\n    // Calculate bounds and positions\r\n    this.calculateTrackBounds(config.path, trackData);\r\n\r\n    console.log(`âœ… Extruded track generated with ${finalConfig.steps} steps`);\r\n    \r\n    return trackData;\r\n  }\r\n\r\n  createDefaultCrossSection(config) {\r\n    const shape = new THREE.Shape();\r\n    const width = config.width || 10;\r\n    const wallHeight = config.wallHeight || 1.5;\r\n    const wallThickness = config.wallThickness || 0.5;\r\n    const trackThickness = config.trackThickness || 0.6;\r\n    \r\n    // Create a U-shaped track cross-section with built-in walls\r\n    // Start from bottom-left\r\n    shape.moveTo(-width/2 - wallThickness, 0);\r\n    \r\n    // Left wall - outer\r\n    shape.lineTo(-width/2 - wallThickness, wallHeight);\r\n    \r\n    // Left wall - top\r\n    shape.lineTo(-width/2, wallHeight);\r\n    \r\n    // Left wall - inner\r\n    shape.lineTo(-width/2, trackThickness);\r\n    \r\n    // Track surface - left edge\r\n    shape.lineTo(-width/2 + wallThickness, trackThickness);\r\n    \r\n    // Optional: Add track grooves or details\r\n    if (config.addGrooves) {\r\n      const grooveWidth = 0.2;\r\n      const grooveDepth = 0.05;\r\n      \r\n      // Left groove\r\n      shape.lineTo(-width/3, trackThickness);\r\n      shape.lineTo(-width/3, trackThickness - grooveDepth);\r\n      shape.lineTo(-width/3 + grooveWidth, trackThickness - grooveDepth);\r\n      shape.lineTo(-width/3 + grooveWidth, trackThickness);\r\n      \r\n      // Center line\r\n      shape.lineTo(-grooveWidth/2, trackThickness);\r\n      shape.lineTo(-grooveWidth/2, trackThickness - grooveDepth);\r\n      shape.lineTo(grooveWidth/2, trackThickness - grooveDepth);\r\n      shape.lineTo(grooveWidth/2, trackThickness);\r\n      \r\n      // Right groove\r\n      shape.lineTo(width/3 - grooveWidth, trackThickness);\r\n      shape.lineTo(width/3 - grooveWidth, trackThickness - grooveDepth);\r\n      shape.lineTo(width/3, trackThickness - grooveDepth);\r\n      shape.lineTo(width/3, trackThickness);\r\n    }\r\n    \r\n    // Track surface - right edge\r\n    shape.lineTo(width/2 - wallThickness, trackThickness);\r\n    \r\n    // Right wall - inner\r\n    shape.lineTo(width/2, trackThickness);\r\n    \r\n    // Right wall - inner up\r\n    shape.lineTo(width/2, wallHeight);\r\n    \r\n    // Right wall - top\r\n    shape.lineTo(width/2 + wallThickness, wallHeight);\r\n    \r\n    // Right wall - outer\r\n    shape.lineTo(width/2 + wallThickness, 0);\r\n    \r\n    // Bottom\r\n    shape.lineTo(-width/2 - wallThickness, 0);\r\n    \r\n    return shape;\r\n  }\r\n\r\n  createTunnelCrossSection(config) {\r\n    const shape = new THREE.Shape();\r\n    const width = config.width || 10;\r\n    const height = config.height || 8;\r\n    const thickness = config.thickness || 1;\r\n    \r\n    // Outer tunnel shape (rounded rectangle)\r\n    const outerRadius = height / 2;\r\n    shape.moveTo(-width/2, 0);\r\n    shape.lineTo(-width/2, height - outerRadius);\r\n    shape.quadraticCurveTo(-width/2, height, -width/2 + outerRadius, height);\r\n    shape.lineTo(width/2 - outerRadius, height);\r\n    shape.quadraticCurveTo(width/2, height, width/2, height - outerRadius);\r\n    shape.lineTo(width/2, 0);\r\n    shape.lineTo(-width/2, 0);\r\n    \r\n    // Create hole for inner tunnel\r\n    const holePath = new THREE.Path();\r\n    const innerWidth = width - thickness * 2;\r\n    const innerHeight = height - thickness;\r\n    const innerRadius = innerHeight / 2;\r\n    \r\n    holePath.moveTo(-innerWidth/2, thickness);\r\n    holePath.lineTo(-innerWidth/2, innerHeight - innerRadius);\r\n    holePath.quadraticCurveTo(-innerWidth/2, innerHeight, -innerWidth/2 + innerRadius, innerHeight);\r\n    holePath.lineTo(innerWidth/2 - innerRadius, innerHeight);\r\n    holePath.quadraticCurveTo(innerWidth/2, innerHeight, innerWidth/2, innerHeight - innerRadius);\r\n    holePath.lineTo(innerWidth/2, thickness);\r\n    holePath.lineTo(-innerWidth/2, thickness);\r\n    \r\n    shape.holes.push(holePath);\r\n    \r\n    return shape;\r\n  }\r\n\r\n  createBridgeCrossSection(config) {\r\n    const shape = new THREE.Shape();\r\n    const width = config.width || 12;\r\n    const railHeight = config.railHeight || 1.2;\r\n    const railWidth = config.railWidth || 0.3;\r\n    const deckThickness = config.deckThickness || 0.8;\r\n    \r\n    // Bridge deck with side rails\r\n    shape.moveTo(-width/2, 0);\r\n    \r\n    // Left rail\r\n    shape.lineTo(-width/2, railHeight);\r\n    shape.lineTo(-width/2 + railWidth, railHeight);\r\n    shape.lineTo(-width/2 + railWidth, deckThickness);\r\n    \r\n    // Deck surface\r\n    shape.lineTo(width/2 - railWidth, deckThickness);\r\n    \r\n    // Right rail\r\n    shape.lineTo(width/2 - railWidth, railHeight);\r\n    shape.lineTo(width/2, railHeight);\r\n    shape.lineTo(width/2, 0);\r\n    \r\n    // Bottom of deck\r\n    shape.lineTo(-width/2, 0);\r\n    \r\n    return shape;\r\n  }\r\n\r\n  generateExtrudedTrack(shape, path, config) {\r\n    // Apply rainbow colors along the path\r\n    const colors = this.generateRainbowColors(config.steps);\r\n    \r\n    // Create extrude settings\r\n    const extrudeSettings = {\r\n      steps: config.steps,\r\n      bevelEnabled: config.bevelEnabled,\r\n      extrudePath: path\r\n    };\r\n\r\n    // Create geometry\r\n    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);\r\n    \r\n    // Add vertex colors\r\n    const colorAttribute = new Float32Array(geometry.attributes.position.count * 3);\r\n    const positions = geometry.attributes.position.array;\r\n    \r\n    // Calculate color for each vertex based on its position along the path\r\n    for (let i = 0; i < geometry.attributes.position.count; i++) {\r\n      const z = positions[i * 3 + 2]; // Assuming extrusion along Z\r\n      const t = (z + path.getLength() / 2) / path.getLength(); // Normalize\r\n      const colorIndex = Math.floor(t * colors.length);\r\n      const color = colors[Math.min(colorIndex, colors.length - 1)];\r\n      \r\n      colorAttribute[i * 3] = color.r;\r\n      colorAttribute[i * 3 + 1] = color.g;\r\n      colorAttribute[i * 3 + 2] = color.b;\r\n    }\r\n    \r\n    geometry.setAttribute('color', new THREE.BufferAttribute(colorAttribute, 3));\r\n    \r\n    // Create material\r\n    const material = this.createTrackMaterial();\r\n    \r\n    // Create mesh\r\n    const mesh = new THREE.Mesh(geometry, material);\r\n    mesh.castShadow = true;\r\n    mesh.receiveShadow = true;\r\n    \r\n    return { mesh, geometry };\r\n  }\r\n\r\n  generateDecorations(path, config) {\r\n    const decorations = [];\r\n    \r\n    // Add distance markers\r\n    if (config.addDistanceMarkers) {\r\n      const markerInterval = 50; // Every 50 units\r\n      const pathLength = path.getLength();\r\n      const markerCount = Math.floor(pathLength / markerInterval);\r\n      \r\n      const markerGeometry = new THREE.BoxGeometry(0.5, 3, 0.5);\r\n      const markerMaterial = new THREE.MeshStandardMaterial({ \r\n        color: 0xff0000,\r\n        emissive: 0xff0000,\r\n        emissiveIntensity: 0.3\r\n      });\r\n      \r\n      const instancedMarkers = new THREE.InstancedMesh(\r\n        markerGeometry,\r\n        markerMaterial,\r\n        markerCount * 2 // Left and right sides\r\n      );\r\n      \r\n      let instanceIndex = 0;\r\n      \r\n      for (let i = 1; i <= markerCount; i++) {\r\n        const t = (i * markerInterval) / pathLength;\r\n        const point = path.getPoint(t);\r\n        const tangent = path.getTangent(t);\r\n        const normal = new THREE.Vector3(0, 1, 0);\r\n        const binormal = new THREE.Vector3().crossVectors(tangent, normal).normalize();\r\n        \r\n        // Left marker\r\n        const leftPos = point.clone().add(binormal.clone().multiplyScalar(-7));\r\n        const leftMatrix = new THREE.Matrix4();\r\n        leftMatrix.setPosition(leftPos);\r\n        instancedMarkers.setMatrixAt(instanceIndex++, leftMatrix);\r\n        \r\n        // Right marker\r\n        const rightPos = point.clone().add(binormal.clone().multiplyScalar(7));\r\n        const rightMatrix = new THREE.Matrix4();\r\n        rightMatrix.setPosition(rightPos);\r\n        instancedMarkers.setMatrixAt(instanceIndex++, rightMatrix);\r\n      }\r\n      \r\n      instancedMarkers.instanceMatrix.needsUpdate = true;\r\n      decorations.push(instancedMarkers);\r\n    }\r\n    \r\n    // Add track lights for tunnels\r\n    if (config.crossSectionType === 'tunnel' && config.addLights) {\r\n      const lightInterval = 20;\r\n      const pathLength = path.getLength();\r\n      const lightCount = Math.floor(pathLength / lightInterval);\r\n      \r\n      const lightGeometry = new THREE.SphereGeometry(0.3, 8, 8);\r\n      const lightMaterial = new THREE.MeshBasicMaterial({ \r\n        color: 0xffff00,\r\n        emissive: 0xffff00\r\n      });\r\n      \r\n      const instancedLights = new THREE.InstancedMesh(\r\n        lightGeometry,\r\n        lightMaterial,\r\n        lightCount\r\n      );\r\n      \r\n      for (let i = 0; i < lightCount; i++) {\r\n        const t = (i * lightInterval) / pathLength;\r\n        const point = path.getPoint(t);\r\n        point.y += config.height - 1; // Position near tunnel ceiling\r\n        \r\n        const matrix = new THREE.Matrix4();\r\n        matrix.setPosition(point);\r\n        instancedLights.setMatrixAt(i, matrix);\r\n      }\r\n      \r\n      instancedLights.instanceMatrix.needsUpdate = true;\r\n      decorations.push(instancedLights);\r\n    }\r\n    \r\n    return decorations;\r\n  }\r\n\r\n  generatePhysicsFromGeometry(geometry, path, config) {\r\n    const bodies = [];\r\n    \r\n    // Simplified physics: Create box segments along the path\r\n    const segmentCount = Math.ceil(path.getLength() / config.segmentLength);\r\n    \r\n    for (let i = 0; i < segmentCount; i++) {\r\n      const t1 = i / segmentCount;\r\n      const t2 = Math.min((i + 1) / segmentCount, 1);\r\n      \r\n      const p1 = path.getPoint(t1);\r\n      const p2 = path.getPoint(t2);\r\n      const center = p1.clone().add(p2).multiplyScalar(0.5);\r\n      const length = p1.distanceTo(p2);\r\n      \r\n      const tangent = path.getTangent((t1 + t2) / 2);\r\n      const quaternion = new THREE.Quaternion().setFromUnitVectors(\r\n        new THREE.Vector3(0, 0, 1),\r\n        tangent\r\n      );\r\n      \r\n      // Create box shape\r\n      const shape = new CANNON.Box(new CANNON.Vec3(\r\n        (config.width || 10) / 2,\r\n        config.trackThickness || 0.6,\r\n        length / 2\r\n      ));\r\n      \r\n      const body = new CANNON.Body({\r\n        mass: 0,\r\n        shape: shape,\r\n        position: new CANNON.Vec3(center.x, center.y, center.z),\r\n        quaternion: new CANNON.Quaternion(\r\n          quaternion.x,\r\n          quaternion.y,\r\n          quaternion.z,\r\n          quaternion.w\r\n        ),\r\n        material: this.trackBuilder.materials.track\r\n      });\r\n      \r\n      bodies.push(body);\r\n    }\r\n    \r\n    console.log(`âš™ï¸ Created ${bodies.length} physics bodies for extruded track`);\r\n    return bodies;\r\n  }\r\n\r\n  calculateTrackBounds(path, trackData) {\r\n    const points = path.getPoints(100);\r\n    let minY = Infinity;\r\n    let maxY = -Infinity;\r\n\r\n    points.forEach(point => {\r\n      minY = Math.min(minY, point.y);\r\n      maxY = Math.max(maxY, point.y);\r\n    });\r\n\r\n    trackData.bounds.minY = minY;\r\n    trackData.bounds.maxY = maxY;\r\n\r\n    // Set start/finish positions\r\n    trackData.startPosition = path.getPoint(0).clone();\r\n    trackData.startPosition.y += 2;\r\n    \r\n    trackData.finishPosition = path.getPoint(0.95).clone(); // Near the end for closed tracks\r\n  }\r\n}"],"names":["ExtrudeGeometryStrategy","TrackGenerationStrategy","trackBuilder","config","finalConfig","shape","trackData","mesh","geometry","decorations","deco","bodies","body","THREE.Shape","width","wallHeight","wallThickness","trackThickness","height","thickness","outerRadius","holePath","THREE.Path","innerWidth","innerHeight","innerRadius","railHeight","railWidth","deckThickness","path","colors","extrudeSettings","THREE.ExtrudeGeometry","colorAttribute","positions","i","t","colorIndex","color","THREE.BufferAttribute","material","THREE.Mesh","pathLength","markerCount","markerGeometry","THREE.BoxGeometry","markerMaterial","THREE.MeshStandardMaterial","instancedMarkers","THREE.InstancedMesh","instanceIndex","point","tangent","normal","THREE.Vector3","binormal","leftPos","leftMatrix","THREE.Matrix4","rightPos","rightMatrix","lightCount","lightGeometry","THREE.SphereGeometry","lightMaterial","THREE.MeshBasicMaterial","instancedLights","matrix","segmentCount","t1","t2","p1","p2","center","length","quaternion","THREE.Quaternion","CANNON.Box","CANNON.Vec3","CANNON.Body","CANNON.Quaternion","points","minY","maxY"],"mappings":"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"}