import{C as F,b as G,B as Q,Q as y,F as b,m as v,c as V,M as I,I as W,V as f,d as B,e as z,f as C,g as Y,h as H}from"./main-Ccht7AUc.js";import{TrackGenerationStrategy as $}from"./TrackGenerationStrategies-DzA-i_rX.js";class N extends ${constructor(t){super(t),this.defaultConfig={segments:200,width:10,thickness:.6,closed:!0,banking:!0,bankingFactor:.5,widthVariation:!1,widthVariationAmount:.3,elevationProfile:null,wallHeight:2,wallThickness:.4,generateWalls:!0,generatePhysics:!0,chunkSize:20}}generate(t){const n={...this.defaultConfig,...t};if(!t.controlPoints||t.controlPoints.length<3)throw new Error("SplineBasedStrategy requires at least 3 control points");console.log("🌊 Generating spline-based track...");const o=new F(t.controlPoints,n.closed,"centripetal"),e={meshes:[],bodies:[],startPosition:null,finishPosition:null,bounds:{minY:1/0,maxY:-1/0}},{mesh:a,segments:r}=this.generateTrackMesh(o,n);if(e.meshes.push(a),this.scene.add(a),n.generateWalls){const i=this.generateWalls(o,r,n);e.meshes.push(...i),i.forEach(l=>this.scene.add(l))}if(n.generatePhysics){const i=this.generatePhysics(r,n);e.bodies=i,i.forEach(l=>this.physicsWorld.addBody(l))}return this.calculateTrackBounds(r,e),console.log(`✅ Spline track generated: ${r.length} segments`),e}generateTrackMesh(t,n){const o=[],e=[],a=this.generateRainbowColors(n.segments),r=t.getPoints(n.segments),i=t.computeFrenetFrames(n.segments,!1);for(let u=0;u<n.segments;u++){const m=this.createSegment(u,r,i,t,n,a[u]);o.push(m);const h=this.createSegmentGeometry(m,n);e.push(h)}const l=this.mergeGeometries(e,n),c=this.createTrackMaterial(),s=new G(l,c);return s.castShadow=!0,s.receiveShadow=!0,e.forEach(u=>u.dispose()),{mesh:s,segments:o}}createSegment(t,n,o,e,a,r){const i=t/a.segments,l=n[t],c=n[Math.min(t+1,n.length-1)],s=o.tangents[t],u=o.normals[t],m=o.binormals[t];let h=a.width;if(a.widthVariation){const p=1+Math.sin(i*Math.PI*4)*a.widthVariationAmount;h*=p}let d=0;if(a.banking){const p=this.calculateCurvature(e,i);d=Math.atan(p*a.bankingFactor),d=Math.max(-Math.PI/6,Math.min(Math.PI/6,d))}if(a.elevationProfile){const p=a.elevationProfile(i);l.y+=p}return{position:l.clone(),nextPosition:c.clone(),tangent:s.clone(),normal:u.clone(),binormal:m.clone(),width:h,bankAngle:d,color:r,t:i}}createSegmentGeometry(t,n){const o=new Q,e=[],a=[],r=[],i=t.nextPosition.clone().sub(t.position);i.length(),i.normalize();const l=t.binormal.clone();if(t.bankAngle!==0){const h=new y().setFromAxisAngle(t.tangent,t.bankAngle);l.applyQuaternion(h)}const c=t.width/2,s=n.thickness/2,u=[t.position.clone().add(l.clone().multiplyScalar(-c)).add(t.normal.clone().multiplyScalar(-s)),t.position.clone().add(l.clone().multiplyScalar(c)).add(t.normal.clone().multiplyScalar(-s)),t.nextPosition.clone().add(l.clone().multiplyScalar(c)).add(t.normal.clone().multiplyScalar(-s)),t.nextPosition.clone().add(l.clone().multiplyScalar(-c)).add(t.normal.clone().multiplyScalar(-s)),t.position.clone().add(l.clone().multiplyScalar(-c)).add(t.normal.clone().multiplyScalar(s)),t.position.clone().add(l.clone().multiplyScalar(c)).add(t.normal.clone().multiplyScalar(s)),t.nextPosition.clone().add(l.clone().multiplyScalar(c)).add(t.normal.clone().multiplyScalar(s)),t.nextPosition.clone().add(l.clone().multiplyScalar(-c)).add(t.normal.clone().multiplyScalar(s))];return[[0,2,1],[0,3,2],[4,5,6],[4,6,7],[0,1,5],[0,5,4],[3,7,6],[3,6,2],[0,4,7],[0,7,3],[1,2,6],[1,6,5]].forEach(h=>{h.forEach(d=>{const p=u[d];e.push(p.x,p.y,p.z),a.push(t.color.r,t.color.g,t.color.b);const w=d%2,S=t.t;r.push(w,S)})}),o.setAttribute("position",new b(e,3)),o.setAttribute("color",new b(a,3)),o.setAttribute("uv",new b(r,2)),o.computeVertexNormals(),o}mergeGeometries(t,n){const o=[];for(let e=0;e<t.length;e+=n.chunkSize){const a=t.slice(e,e+n.chunkSize),r=v(a);o.push(r)}if(o.length>1){const e=v(o);return o.forEach(a=>a.dispose()),e}return o[0]}generateWalls(t,n,o){const e=[],a=new V(o.wallThickness,o.wallHeight,1),r=new I({color:3355443,roughness:.9,metalness:.1}),i=n.length*2,l=new W(a,r,i);l.castShadow=!0,l.receiveShadow=!0;let c=0;return n.forEach((s,u)=>{const m=n[Math.min(u+1,n.length-1)],h=s.position.distanceTo(m.position),d=s.binormal.clone(),p=s.normal.clone();if(s.bankAngle!==0){const A=new y().setFromAxisAngle(s.tangent,s.bankAngle);d.applyQuaternion(A),p.applyQuaternion(A)}const S=s.width/2+o.wallThickness/2,k=o.wallHeight/2+o.thickness/2,T=s.position.clone().add(d.clone().multiplyScalar(-S)).add(p.clone().multiplyScalar(k)),E=s.position.clone().add(d.clone().multiplyScalar(S)).add(p.clone().multiplyScalar(k)),g=new f(1,1,h),M=new B,P=new y().setFromUnitVectors(new f(0,0,1),s.tangent);M.compose(T,P,g),l.setMatrixAt(c++,M);const x=new B;x.compose(E,P,g),l.setMatrixAt(c++,x)}),l.instanceMatrix.needsUpdate=!0,l.count=c,e.push(l),console.log(`🧱 Created ${c} wall instances`),e}generatePhysics(t,n){const o=[],e=[],a=[],r=[];return t.forEach((i,l)=>{const c=t[Math.min(l+1,t.length-1)],s=i.position.distanceTo(c.position),u=new z(new C(i.width/2,n.thickness/2,s/2)),m=i.position.clone().add(c.position).multiplyScalar(.5),h=new y().setFromUnitVectors(new f(0,0,1),i.tangent);if(i.bankAngle!==0){const d=new y().setFromAxisAngle(i.tangent,i.bankAngle);h.multiply(d)}if(e.push(u),a.push(new C(m.x,m.y,m.z)),r.push(new Y(h.x,h.y,h.z,h.w)),(l+1)%n.chunkSize===0||l===t.length-1){const d=new H({mass:0,material:this.trackBuilder.materials.track});e.forEach((p,w)=>{d.addShape(p,a[w],r[w])}),o.push(d),e.length=0,a.length=0,r.length=0}}),console.log(`⚙️ Created ${o.length} compound physics bodies`),o}calculateCurvature(t,n){const e=Math.max(0,n-.01),a=n,r=Math.min(1,n+.01),i=t.getPoint(e),l=t.getPoint(a),c=t.getPoint(r),s=l.clone().sub(i),u=c.clone().sub(l),m=s.clone().cross(u),h=s.length()*u.length();return h===0?0:m.length()/h}calculateTrackBounds(t,n){let o=1/0,e=-1/0;if(t.forEach(a=>{o=Math.min(o,a.position.y),e=Math.max(e,a.position.y)}),n.bounds.minY=o,n.bounds.maxY=e,t.length>0){n.startPosition=t[0].position.clone(),n.startPosition.y+=2;const a=t[t.length-1];n.finishPosition=a.position.clone()}}}export{N as SplineBasedStrategy};
//# sourceMappingURL=SplineBasedStrategy-BTOxYX87.js.map
