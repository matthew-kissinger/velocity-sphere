{"version":3,"file":"SplineBasedStrategy-BTOxYX87.js","sources":["../../src/tracks/generation/SplineBasedStrategy.js"],"sourcesContent":["/**\r\n * SplineBasedStrategy - Smooth track generation using Three.js splines\r\n * \r\n * Creates racing tracks from control points using CatmullRomCurve3 for smooth interpolation.\r\n * Features:\r\n * - Automatic banking based on curvature\r\n * - Variable track width\r\n * - Elevation profiles\r\n * - Optimized geometry generation\r\n */\r\n\r\nimport * as THREE from 'three';\r\nimport * as CANNON from 'cannon-es';\r\nimport * as BufferGeometryUtils from 'three/examples/jsm/utils/BufferGeometryUtils.js';\r\nimport { TrackGenerationStrategy } from './TrackGenerationStrategies.js';\r\n\r\nexport class SplineBasedStrategy extends TrackGenerationStrategy {\r\n  constructor(trackBuilder) {\r\n    super(trackBuilder);\r\n    this.defaultConfig = {\r\n      segments: 200,\r\n      width: 10,\r\n      thickness: 0.6,\r\n      closed: true,\r\n      banking: true,\r\n      bankingFactor: 0.5,\r\n      widthVariation: false,\r\n      widthVariationAmount: 0.3,\r\n      elevationProfile: null,\r\n      wallHeight: 2.0,\r\n      wallThickness: 0.4,\r\n      generateWalls: true,\r\n      generatePhysics: true,\r\n      chunkSize: 20 // For geometry merging\r\n    };\r\n  }\r\n\r\n  generate(config) {\r\n    const finalConfig = { ...this.defaultConfig, ...config };\r\n    \r\n    if (!config.controlPoints || config.controlPoints.length < 3) {\r\n      throw new Error('SplineBasedStrategy requires at least 3 control points');\r\n    }\r\n\r\n    console.log('🌊 Generating spline-based track...');\r\n\r\n    // Create spline from control points\r\n    const curve = new THREE.CatmullRomCurve3(\r\n      config.controlPoints,\r\n      finalConfig.closed,\r\n      'centripetal'\r\n    );\r\n\r\n    // Generate track data\r\n    const trackData = {\r\n      meshes: [],\r\n      bodies: [],\r\n      startPosition: null,\r\n      finishPosition: null,\r\n      bounds: { minY: Infinity, maxY: -Infinity }\r\n    };\r\n\r\n    // Generate track geometry\r\n    const { mesh, segments } = this.generateTrackMesh(curve, finalConfig);\r\n    trackData.meshes.push(mesh);\r\n    this.scene.add(mesh);\r\n\r\n    // Generate walls if enabled\r\n    if (finalConfig.generateWalls) {\r\n      const wallMeshes = this.generateWalls(curve, segments, finalConfig);\r\n      trackData.meshes.push(...wallMeshes);\r\n      wallMeshes.forEach(wall => this.scene.add(wall));\r\n    }\r\n\r\n    // Generate physics if enabled\r\n    if (finalConfig.generatePhysics) {\r\n      const bodies = this.generatePhysics(segments, finalConfig);\r\n      trackData.bodies = bodies;\r\n      bodies.forEach(body => this.physicsWorld.addBody(body));\r\n    }\r\n\r\n    // Calculate bounds and positions\r\n    this.calculateTrackBounds(segments, trackData);\r\n\r\n    console.log(`✅ Spline track generated: ${segments.length} segments`);\r\n    \r\n    return trackData;\r\n  }\r\n\r\n  generateTrackMesh(curve, config) {\r\n    const segments = [];\r\n    const geometries = [];\r\n    const colors = this.generateRainbowColors(config.segments);\r\n    \r\n    // Sample points along the curve\r\n    const points = curve.getPoints(config.segments);\r\n    const frames = curve.computeFrenetFrames(config.segments, false);\r\n\r\n    // Generate segments\r\n    for (let i = 0; i < config.segments; i++) {\r\n      const segment = this.createSegment(\r\n        i,\r\n        points,\r\n        frames,\r\n        curve,\r\n        config,\r\n        colors[i]\r\n      );\r\n      segments.push(segment);\r\n      \r\n      // Create geometry for this segment\r\n      const geometry = this.createSegmentGeometry(segment, config);\r\n      geometries.push(geometry);\r\n    }\r\n\r\n    // Merge geometries for performance\r\n    const mergedGeometry = this.mergeGeometries(geometries, config);\r\n    const material = this.createTrackMaterial();\r\n    const mesh = new THREE.Mesh(mergedGeometry, material);\r\n    mesh.castShadow = true;\r\n    mesh.receiveShadow = true;\r\n\r\n    // Clean up individual geometries\r\n    geometries.forEach(geo => geo.dispose());\r\n\r\n    return { mesh, segments };\r\n  }\r\n\r\n  createSegment(index, points, frames, curve, config, color) {\r\n    const t = index / config.segments;\r\n    const point = points[index];\r\n    const nextPoint = points[Math.min(index + 1, points.length - 1)];\r\n    \r\n    // Get frame vectors\r\n    const tangent = frames.tangents[index];\r\n    const normal = frames.normals[index];\r\n    const binormal = frames.binormals[index];\r\n\r\n    // Calculate track width (with optional variation)\r\n    let width = config.width;\r\n    if (config.widthVariation) {\r\n      const widthMultiplier = 1 + Math.sin(t * Math.PI * 4) * config.widthVariationAmount;\r\n      width *= widthMultiplier;\r\n    }\r\n\r\n    // Calculate banking angle based on curvature\r\n    let bankAngle = 0;\r\n    if (config.banking) {\r\n      const curvature = this.calculateCurvature(curve, t);\r\n      bankAngle = Math.atan(curvature * config.bankingFactor);\r\n      bankAngle = Math.max(-Math.PI / 6, Math.min(Math.PI / 6, bankAngle)); // Limit to ±30°\r\n    }\r\n\r\n    // Apply elevation profile if provided\r\n    if (config.elevationProfile) {\r\n      const elevation = config.elevationProfile(t);\r\n      point.y += elevation;\r\n    }\r\n\r\n    return {\r\n      position: point.clone(),\r\n      nextPosition: nextPoint.clone(),\r\n      tangent: tangent.clone(),\r\n      normal: normal.clone(),\r\n      binormal: binormal.clone(),\r\n      width,\r\n      bankAngle,\r\n      color,\r\n      t\r\n    };\r\n  }\r\n\r\n  createSegmentGeometry(segment, config) {\r\n    const geometry = new THREE.BufferGeometry();\r\n    const vertices = [];\r\n    const normals = [];\r\n    const colors = [];\r\n    const uvs = [];\r\n\r\n    // Calculate segment vectors\r\n    const forward = segment.nextPosition.clone().sub(segment.position);\r\n    const segmentLength = forward.length();\r\n    forward.normalize();\r\n\r\n    // Apply banking rotation to binormal\r\n    const bankedBinormal = segment.binormal.clone();\r\n    if (segment.bankAngle !== 0) {\r\n      const bankQuat = new THREE.Quaternion().setFromAxisAngle(segment.tangent, segment.bankAngle);\r\n      bankedBinormal.applyQuaternion(bankQuat);\r\n    }\r\n\r\n    // Calculate corner positions\r\n    const halfWidth = segment.width / 2;\r\n    const halfThickness = config.thickness / 2;\r\n\r\n    // Define 8 vertices for the track segment box\r\n    const corners = [\r\n      // Bottom face (4 vertices)\r\n      segment.position.clone().add(bankedBinormal.clone().multiplyScalar(-halfWidth))\r\n        .add(segment.normal.clone().multiplyScalar(-halfThickness)),\r\n      segment.position.clone().add(bankedBinormal.clone().multiplyScalar(halfWidth))\r\n        .add(segment.normal.clone().multiplyScalar(-halfThickness)),\r\n      segment.nextPosition.clone().add(bankedBinormal.clone().multiplyScalar(halfWidth))\r\n        .add(segment.normal.clone().multiplyScalar(-halfThickness)),\r\n      segment.nextPosition.clone().add(bankedBinormal.clone().multiplyScalar(-halfWidth))\r\n        .add(segment.normal.clone().multiplyScalar(-halfThickness)),\r\n      \r\n      // Top face (4 vertices)\r\n      segment.position.clone().add(bankedBinormal.clone().multiplyScalar(-halfWidth))\r\n        .add(segment.normal.clone().multiplyScalar(halfThickness)),\r\n      segment.position.clone().add(bankedBinormal.clone().multiplyScalar(halfWidth))\r\n        .add(segment.normal.clone().multiplyScalar(halfThickness)),\r\n      segment.nextPosition.clone().add(bankedBinormal.clone().multiplyScalar(halfWidth))\r\n        .add(segment.normal.clone().multiplyScalar(halfThickness)),\r\n      segment.nextPosition.clone().add(bankedBinormal.clone().multiplyScalar(-halfWidth))\r\n        .add(segment.normal.clone().multiplyScalar(halfThickness))\r\n    ];\r\n\r\n    // Define faces (12 triangles for a box)\r\n    const faces = [\r\n      // Bottom\r\n      [0, 2, 1], [0, 3, 2],\r\n      // Top\r\n      [4, 5, 6], [4, 6, 7],\r\n      // Front\r\n      [0, 1, 5], [0, 5, 4],\r\n      // Back\r\n      [3, 7, 6], [3, 6, 2],\r\n      // Left\r\n      [0, 4, 7], [0, 7, 3],\r\n      // Right\r\n      [1, 2, 6], [1, 6, 5]\r\n    ];\r\n\r\n    // Build vertex data\r\n    faces.forEach(face => {\r\n      face.forEach(vertexIndex => {\r\n        const vertex = corners[vertexIndex];\r\n        vertices.push(vertex.x, vertex.y, vertex.z);\r\n        \r\n        // Add color\r\n        colors.push(segment.color.r, segment.color.g, segment.color.b);\r\n        \r\n        // Add UV (simple mapping)\r\n        const u = vertexIndex % 2;\r\n        const v = segment.t;\r\n        uvs.push(u, v);\r\n      });\r\n    });\r\n\r\n    // Set attributes\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\r\n    geometry.computeVertexNormals();\r\n\r\n    return geometry;\r\n  }\r\n\r\n  mergeGeometries(geometries, config) {\r\n    // Merge in chunks for better performance\r\n    const chunks = [];\r\n    for (let i = 0; i < geometries.length; i += config.chunkSize) {\r\n      const chunk = geometries.slice(i, i + config.chunkSize);\r\n                  const merged = BufferGeometryUtils.mergeGeometries(chunk);\r\n      chunks.push(merged);\r\n    }\r\n\r\n    // If we have multiple chunks, merge them all\r\n    if (chunks.length > 1) {\r\n      const finalMerged = BufferGeometryUtils.mergeGeometries(chunks);\r\n      chunks.forEach(chunk => chunk.dispose());\r\n      return finalMerged;\r\n    }\r\n\r\n    return chunks[0];\r\n  }\r\n\r\n  generateWalls(curve, segments, config) {\r\n    const wallMeshes = [];\r\n    \r\n    // Use instanced mesh for walls\r\n    const wallGeometry = new THREE.BoxGeometry(\r\n      config.wallThickness,\r\n      config.wallHeight,\r\n      1 // Will be scaled per instance\r\n    );\r\n\r\n    const wallMaterial = new THREE.MeshStandardMaterial({\r\n      color: 0x333333,\r\n      roughness: 0.9,\r\n      metalness: 0.1\r\n    });\r\n\r\n    // Calculate total wall instances needed\r\n    const wallCount = segments.length * 2; // Left and right walls\r\n    const instancedWalls = new THREE.InstancedMesh(\r\n      wallGeometry,\r\n      wallMaterial,\r\n      wallCount\r\n    );\r\n    instancedWalls.castShadow = true;\r\n    instancedWalls.receiveShadow = true;\r\n\r\n    let instanceIndex = 0;\r\n\r\n    segments.forEach((segment, i) => {\r\n      const nextSegment = segments[Math.min(i + 1, segments.length - 1)];\r\n      const segmentLength = segment.position.distanceTo(nextSegment.position);\r\n      \r\n      // Apply banking to binormal for wall placement\r\n      const bankedBinormal = segment.binormal.clone();\r\n      const bankedNormal = segment.normal.clone();\r\n      if (segment.bankAngle !== 0) {\r\n        const bankQuat = new THREE.Quaternion().setFromAxisAngle(segment.tangent, segment.bankAngle);\r\n        bankedBinormal.applyQuaternion(bankQuat);\r\n        bankedNormal.applyQuaternion(bankQuat);\r\n      }\r\n\r\n      // Calculate wall positions\r\n      const halfWidth = segment.width / 2;\r\n      const wallOffset = halfWidth + config.wallThickness / 2;\r\n      const wallHeight = config.wallHeight / 2 + config.thickness / 2;\r\n\r\n      // Left wall\r\n      const leftPos = segment.position.clone()\r\n        .add(bankedBinormal.clone().multiplyScalar(-wallOffset))\r\n        .add(bankedNormal.clone().multiplyScalar(wallHeight));\r\n\r\n      // Right wall\r\n      const rightPos = segment.position.clone()\r\n        .add(bankedBinormal.clone().multiplyScalar(wallOffset))\r\n        .add(bankedNormal.clone().multiplyScalar(wallHeight));\r\n\r\n      // Create transformation matrices\r\n      const scale = new THREE.Vector3(1, 1, segmentLength);\r\n      \r\n      // Left wall matrix\r\n      const leftMatrix = new THREE.Matrix4();\r\n      const leftQuat = new THREE.Quaternion().setFromUnitVectors(\r\n        new THREE.Vector3(0, 0, 1),\r\n        segment.tangent\r\n      );\r\n      leftMatrix.compose(leftPos, leftQuat, scale);\r\n      instancedWalls.setMatrixAt(instanceIndex++, leftMatrix);\r\n\r\n      // Right wall matrix\r\n      const rightMatrix = new THREE.Matrix4();\r\n      rightMatrix.compose(rightPos, leftQuat, scale);\r\n      instancedWalls.setMatrixAt(instanceIndex++, rightMatrix);\r\n    });\r\n\r\n    instancedWalls.instanceMatrix.needsUpdate = true;\r\n    instancedWalls.count = instanceIndex;\r\n\r\n    wallMeshes.push(instancedWalls);\r\n    console.log(`🧱 Created ${instanceIndex} wall instances`);\r\n\r\n    return wallMeshes;\r\n  }\r\n\r\n  generatePhysics(segments, config) {\r\n    const bodies = [];\r\n    \r\n    // Create compound shapes for better performance\r\n    const compoundShapes = [];\r\n    const compoundPositions = [];\r\n    const compoundQuaternions = [];\r\n\r\n    segments.forEach((segment, i) => {\r\n      const nextSegment = segments[Math.min(i + 1, segments.length - 1)];\r\n      const segmentLength = segment.position.distanceTo(nextSegment.position);\r\n      \r\n      // Create box shape for this segment\r\n      const shape = new CANNON.Box(new CANNON.Vec3(\r\n        segment.width / 2,\r\n        config.thickness / 2,\r\n        segmentLength / 2\r\n      ));\r\n\r\n      // Calculate position (center between segment and next)\r\n      const center = segment.position.clone().add(nextSegment.position).multiplyScalar(0.5);\r\n      \r\n      // Calculate orientation\r\n      const quaternion = new THREE.Quaternion().setFromUnitVectors(\r\n        new THREE.Vector3(0, 0, 1),\r\n        segment.tangent\r\n      );\r\n\r\n      // Apply banking\r\n      if (segment.bankAngle !== 0) {\r\n        const bankQuat = new THREE.Quaternion().setFromAxisAngle(\r\n          segment.tangent,\r\n          segment.bankAngle\r\n        );\r\n        quaternion.multiply(bankQuat);\r\n      }\r\n\r\n      compoundShapes.push(shape);\r\n      compoundPositions.push(new CANNON.Vec3(center.x, center.y, center.z));\r\n      compoundQuaternions.push(new CANNON.Quaternion(\r\n        quaternion.x,\r\n        quaternion.y,\r\n        quaternion.z,\r\n        quaternion.w\r\n      ));\r\n\r\n      // Create compound body every N segments\r\n      if ((i + 1) % config.chunkSize === 0 || i === segments.length - 1) {\r\n        const body = new CANNON.Body({\r\n          mass: 0,\r\n          material: this.trackBuilder.materials.track\r\n        });\r\n\r\n        compoundShapes.forEach((shape, j) => {\r\n          body.addShape(shape, compoundPositions[j], compoundQuaternions[j]);\r\n        });\r\n\r\n        bodies.push(body);\r\n\r\n        // Reset arrays\r\n        compoundShapes.length = 0;\r\n        compoundPositions.length = 0;\r\n        compoundQuaternions.length = 0;\r\n      }\r\n    });\r\n\r\n    console.log(`⚙️ Created ${bodies.length} compound physics bodies`);\r\n    return bodies;\r\n  }\r\n\r\n  calculateCurvature(curve, t) {\r\n    const delta = 0.01;\r\n    const t0 = Math.max(0, t - delta);\r\n    const t1 = t;\r\n    const t2 = Math.min(1, t + delta);\r\n\r\n    const p0 = curve.getPoint(t0);\r\n    const p1 = curve.getPoint(t1);\r\n    const p2 = curve.getPoint(t2);\r\n\r\n    const v1 = p1.clone().sub(p0);\r\n    const v2 = p2.clone().sub(p1);\r\n\r\n    const cross = v1.clone().cross(v2);\r\n    const denom = v1.length() * v2.length();\r\n\r\n    if (denom === 0) return 0;\r\n    \r\n    return cross.length() / denom;\r\n  }\r\n\r\n  calculateTrackBounds(segments, trackData) {\r\n    let minY = Infinity;\r\n    let maxY = -Infinity;\r\n\r\n    segments.forEach(segment => {\r\n      minY = Math.min(minY, segment.position.y);\r\n      maxY = Math.max(maxY, segment.position.y);\r\n    });\r\n\r\n    trackData.bounds.minY = minY;\r\n    trackData.bounds.maxY = maxY;\r\n\r\n    // Set start/finish positions\r\n    if (segments.length > 0) {\r\n      trackData.startPosition = segments[0].position.clone();\r\n      trackData.startPosition.y += 2; // Spawn above track\r\n      \r\n      const lastSegment = segments[segments.length - 1];\r\n      trackData.finishPosition = lastSegment.position.clone();\r\n    }\r\n  }\r\n}"],"names":["SplineBasedStrategy","TrackGenerationStrategy","trackBuilder","config","finalConfig","curve","THREE.CatmullRomCurve3","trackData","mesh","segments","wallMeshes","wall","bodies","body","geometries","colors","points","frames","i","segment","geometry","mergedGeometry","material","THREE.Mesh","geo","index","color","t","point","nextPoint","tangent","normal","binormal","width","widthMultiplier","bankAngle","curvature","elevation","THREE.BufferGeometry","vertices","uvs","forward","bankedBinormal","bankQuat","THREE.Quaternion","halfWidth","halfThickness","corners","face","vertexIndex","vertex","u","v","THREE.Float32BufferAttribute","chunks","chunk","merged","BufferGeometryUtils.mergeGeometries","finalMerged","wallGeometry","THREE.BoxGeometry","wallMaterial","THREE.MeshStandardMaterial","wallCount","instancedWalls","THREE.InstancedMesh","instanceIndex","nextSegment","segmentLength","bankedNormal","wallOffset","wallHeight","leftPos","rightPos","scale","THREE.Vector3","leftMatrix","THREE.Matrix4","leftQuat","rightMatrix","compoundShapes","compoundPositions","compoundQuaternions","shape","CANNON.Box","CANNON.Vec3","center","quaternion","CANNON.Quaternion","CANNON.Body","j","t0","t1","t2","p0","p1","p2","v1","v2","cross","denom","minY","maxY","lastSegment"],"mappings":"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"}