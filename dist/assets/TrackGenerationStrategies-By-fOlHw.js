const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/SplineBasedStrategy-dJ7dBXKN.js","assets/main-Dd-xMgWp.js","assets/main-D7eN2pOY.css","assets/ExtrudeGeometryStrategy-Db3OX-9A.js"])))=>i.map(i=>d[i]);
var l=Object.defineProperty;var u=(a,e,t)=>e in a?l(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var i=(a,e,t)=>u(a,typeof e!="symbol"?e+"":e,t);import{S as g,_ as c,C as d,M as h,a as S}from"./main-Dd-xMgWp.js";class n{constructor(e){this.trackBuilder=e,this.scene=e.scene,this.physicsWorld=e.physicsWorld}generate(e){throw new Error("generate() must be implemented by subclass")}createTrackMaterial(){return new h({vertexColors:!0,roughness:.8,metalness:.1,map:this.trackBuilder.trackTexture})}generateRainbowColors(e){const t=[];for(let r=0;r<e;r++){const s=r/e*.65,o=new S;o.setHSL(s,1,.5),t.push(o)}return t}}class y extends n{generate(e){return this.trackBuilder.buildTrackFromSegments(e)}}class p extends n{constructor(e){super(e),this.defaultConfig={segments:200,width:10,thickness:.6,closed:!0,banking:!0,bankingFactor:.5,widthVariation:!1,elevationProfile:null}}generate(e){const t={...this.defaultConfig,...e};if(!e.controlPoints||e.controlPoints.length<3)throw new Error("SplineBasedStrategy requires at least 3 control points");const r=new d(e.controlPoints,t.closed,"centripetal");return this.generateTrackFromSpline(r,t)}async generate(e){const{SplineBasedStrategy:t}=await c(async()=>{const{SplineBasedStrategy:s}=await import("./SplineBasedStrategy-dJ7dBXKN.js");return{SplineBasedStrategy:s}},__vite__mapDeps([0,1,2]));return new t(this.trackBuilder).generate(e)}}class w extends n{constructor(e){super(e),this.defaultConfig={steps:200,bevelEnabled:!1,closed:!0,crossSection:null}}generate(e){const t={...this.defaultConfig,...e};if(!e.path)throw new Error("ExtrudeBasedStrategy requires a path (curve)");const r=t.crossSection||this.createDefaultCrossSection();return this.generateExtrudedTrack(r,e.path,t)}createDefaultCrossSection(){const e=new g,t=10,r=.5;return e.moveTo(-t/2,0),e.lineTo(-t/2,r),e.lineTo(-t/2+.5,r),e.lineTo(-t/2+.5,.1),e.lineTo(t/2-.5,.1),e.lineTo(t/2-.5,r),e.lineTo(t/2,r),e.lineTo(t/2,0),e.closePath(),e}async generate(e){const{ExtrudeGeometryStrategy:t}=await c(async()=>{const{ExtrudeGeometryStrategy:s}=await import("./ExtrudeGeometryStrategy-Db3OX-9A.js");return{ExtrudeGeometryStrategy:s}},__vite__mapDeps([3,1,2]));return new t(this.trackBuilder).generate(e)}}class f extends n{constructor(e){super(e),this.defaultConfig={seed:Date.now(),length:200,complexity:.5,elevationVariance:20,widthVariance:.3,cornerSharpness:.5}}generate(e){const t={...this.defaultConfig,...e};return this.rng=this.createSeededRandom(t.seed),this.generateProceduralTrack(t)}createSeededRandom(e){let t=e;return()=>(t=Math.sin(t)*1e4,t-Math.floor(t))}generateProceduralTrack(e){throw new Error("Not yet implemented - see ProceduralStrategy.js")}}class m{static createStrategy(e,t){const r=this.strategies[e];if(!r)throw new Error(`Unknown track generation strategy: ${e}`);return new r(t)}static getAvailableStrategies(){return Object.keys(this.strategies)}}i(m,"strategies",{segment:y,spline:p,extrude:w,procedural:f});export{w as ExtrudeBasedStrategy,f as ProceduralStrategy,y as SegmentBasedStrategy,p as SplineBasedStrategy,m as TrackGenerationFactory,n as TrackGenerationStrategy};
//# sourceMappingURL=TrackGenerationStrategies-By-fOlHw.js.map
