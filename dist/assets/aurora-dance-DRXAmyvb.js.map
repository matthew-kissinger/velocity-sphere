{"version":3,"file":"aurora-dance-DRXAmyvb.js","sources":["../../src/skyboxes/aurora-dance.js"],"sourcesContent":["/**\r\n * Aurora Dance Skybox\r\n * Dancing northern lights with magical atmosphere\r\n * Perfect for mystical/magical tracks\r\n */\r\n\r\nimport * as THREE from 'three';\r\n\r\nexport default {\r\n  name: 'aurora-dance',\r\n  description: 'Dancing aurora borealis with magical atmosphere',\r\n  author: 'Velocity Sphere Team',\r\n  version: '1.0.0',\r\n  tags: ['aurora', 'magical', 'lights', 'mystical'],\r\n  mood: 'magical',\r\n  \r\n  uniforms: {\r\n    auroraColor1: { value: new THREE.Color(0x00ff88) },\r\n    auroraColor2: { value: new THREE.Color(0x0088ff) },\r\n    auroraColor3: { value: new THREE.Color(0xff4488) },\r\n    auroraIntensity: { value: 1.5 },\r\n    waveSpeed: { value: 1.0 }\r\n  },\r\n  \r\n  vertexShader: `\r\n    varying vec3 vWorldPosition;\r\n    varying vec3 vPosition;\r\n    \r\n    void main() {\r\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\r\n      vWorldPosition = worldPosition.xyz;\r\n      vPosition = position;\r\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    }\r\n  `,\r\n  \r\n  fragmentShader: `\r\n    uniform float time;\r\n    uniform vec3 auroraColor1;\r\n    uniform vec3 auroraColor2;\r\n    uniform vec3 auroraColor3;\r\n    uniform float auroraIntensity;\r\n    uniform float waveSpeed;\r\n    \r\n    varying vec3 vWorldPosition;\r\n    varying vec3 vPosition;\r\n    \r\n    // Noise functions\r\n    float noise(vec2 p) {\r\n      return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\r\n    }\r\n    \r\n    float smoothNoise(vec2 p) {\r\n      vec2 i = floor(p);\r\n      vec2 f = fract(p);\r\n      f = f * f * (3.0 - 2.0 * f);\r\n      \r\n      float a = noise(i);\r\n      float b = noise(i + vec2(1.0, 0.0));\r\n      float c = noise(i + vec2(0.0, 1.0));\r\n      float d = noise(i + vec2(1.0, 1.0));\r\n      \r\n      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\r\n    }\r\n    \r\n    float fbm(vec2 p) {\r\n      float value = 0.0;\r\n      float amplitude = 0.5;\r\n      for(int i = 0; i < 6; i++) {\r\n        value += amplitude * smoothNoise(p);\r\n        p *= 2.0;\r\n        amplitude *= 0.5;\r\n      }\r\n      return value;\r\n    }\r\n    \r\n    void main() {\r\n      vec3 direction = normalize(vWorldPosition);\r\n      float y = direction.y;\r\n      \r\n      // Base night sky\r\n      vec3 nightSky = vec3(0.01, 0.02, 0.05);\r\n      vec3 starColor = vec3(0.8, 0.9, 1.0);\r\n      \r\n      // Add stars\r\n      float starNoise = noise(direction.xz * 100.0);\r\n      float stars = smoothstep(0.98, 1.0, starNoise) * 0.5;\r\n      vec3 color = nightSky + starColor * stars;\r\n      \r\n      // Aurora generation - only in upper sky\r\n      if (y > 0.1) {\r\n        // Create flowing aurora patterns\r\n        float wave1 = sin(direction.x * 3.0 + time * waveSpeed) * cos(direction.z * 2.0 + time * waveSpeed * 0.7);\r\n        float wave2 = sin(direction.x * 5.0 + time * waveSpeed * 1.3) * cos(direction.z * 4.0 + time * waveSpeed * 0.9);\r\n        float wave3 = sin(direction.x * 2.0 + time * waveSpeed * 0.6) * cos(direction.z * 3.0 + time * waveSpeed * 1.1);\r\n        \r\n        // Combine waves with noise\r\n        float auroraPattern = (wave1 + wave2 * 0.7 + wave3 * 0.5) / 2.2;\r\n        auroraPattern += fbm(direction.xz * 2.0 + time * 0.2) * 0.3;\r\n        \r\n        // Create height falloff for aurora\r\n        float heightFactor = smoothstep(0.1, 0.8, y) * (1.0 - smoothstep(0.8, 1.0, y));\r\n        \r\n        // Apply aurora effect\r\n        if (auroraPattern > 0.2) {\r\n          float intensity = (auroraPattern - 0.2) * heightFactor * auroraIntensity;\r\n          \r\n          // Mix aurora colors based on pattern and time\r\n          float colorMix1 = sin(time * 0.8 + auroraPattern * 5.0) * 0.5 + 0.5;\r\n          float colorMix2 = cos(time * 1.2 + auroraPattern * 3.0) * 0.5 + 0.5;\r\n          \r\n          vec3 aurora1 = mix(auroraColor1, auroraColor2, colorMix1);\r\n          vec3 aurora2 = mix(auroraColor2, auroraColor3, colorMix2);\r\n          vec3 auroraColor = mix(aurora1, aurora2, sin(time + auroraPattern) * 0.5 + 0.5);\r\n          \r\n          // Add aurora to sky\r\n          color += auroraColor * intensity * 0.3;\r\n          \r\n          // Add glow effect\r\n          color += auroraColor * intensity * 0.1 * (1.0 + sin(time * 2.0) * 0.2);\r\n        }\r\n      }\r\n      \r\n      // Add subtle atmospheric glow near horizon\r\n      if (y < 0.3 && y > -0.2) {\r\n        float horizonGlow = 1.0 - abs(y - 0.05) / 0.35;\r\n        horizonGlow = pow(horizonGlow, 2.0);\r\n        vec3 glowColor = mix(auroraColor1, auroraColor2, sin(time * 0.5) * 0.5 + 0.5);\r\n        color += glowColor * horizonGlow * 0.05;\r\n      }\r\n      \r\n      // Add subtle shimmer\r\n      float shimmer = sin(time * 1.5 + direction.x + direction.z) * 0.03 + 0.97;\r\n      color *= shimmer;\r\n      \r\n      gl_FragColor = vec4(color, 1.0);\r\n    }\r\n  `\r\n};"],"names":["auroraDance","THREE.Color"],"mappings":"uCAQA,MAAAA,EAAe,CACb,KAAM,eACN,YAAa,kDACb,OAAQ,uBACR,QAAS,QACT,KAAM,CAAC,SAAU,UAAW,SAAU,UAAU,EAChD,KAAM,UAEN,SAAU,CACR,aAAc,CAAE,MAAO,IAAIC,EAAY,KAAQ,CAAC,EAChD,aAAc,CAAE,MAAO,IAAIA,EAAY,KAAQ,CAAC,EAChD,aAAc,CAAE,MAAO,IAAIA,EAAY,QAAQ,CAAC,EAChD,gBAAiB,CAAE,MAAO,GAAG,EAC7B,UAAW,CAAE,MAAO,CAAG,CAC3B,EAEE,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYd,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAsGlB"}