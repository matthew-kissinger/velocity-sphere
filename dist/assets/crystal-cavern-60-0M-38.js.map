{"version":3,"file":"crystal-cavern-60-0M-38.js","sources":["../../src/skyboxes/crystal-cavern.js"],"sourcesContent":["/**\n * Crystal Cavern Skybox\n * Vibrant underground atmosphere with glowing crystals\n * Bright and colorful cave environment\n */\n\nexport default {\n  name: 'crystal-cavern',\n  description: 'Vibrant crystal cave with bioluminescent glow',\n  author: 'Circuit Beta Fix Team',\n  version: '1.0.0',\n  tags: ['crystal', 'cave', 'vibrant', 'glow', 'underground'],\n  mood: 'mystical',\n  \n  uniforms: {\n    crystalGlow: { value: 0.8 },\n    colorShift: { value: 0.5 },\n    pulseSpeed: { value: 1.0 }\n  },\n  \n  vertexShader: `\n    varying vec3 vWorldPosition;\n    varying vec3 vPosition;\n    \n    void main() {\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPosition.xyz;\n      vPosition = position;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  \n  fragmentShader: `\n    uniform float time;\n    uniform float crystalGlow;\n    uniform float colorShift;\n    uniform float pulseSpeed;\n    \n    varying vec3 vWorldPosition;\n    varying vec3 vPosition;\n    \n    // Hash for randomness\n    float hash(vec2 p) {\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n    }\n    \n    vec3 hash3(vec2 p) {\n      vec3 p3 = vec3(p.xyx) * vec3(443.8975, 397.2973, 491.1871);\n      p3 = fract(p3 * 0.1031);\n      p3 += dot(p3, p3.yxz + 19.19);\n      return fract((p3.xxy + p3.yxx) * p3.zyx);\n    }\n    \n    // Crystal pattern\n    float crystalPattern(vec2 p) {\n      vec2 id = floor(p);\n      vec2 f = fract(p);\n      \n      float minDist = 1.0;\n      \n      // Check neighboring cells for crystal positions\n      for (int x = -1; x <= 1; x++) {\n        for (int y = -1; y <= 1; y++) {\n          vec2 neighbor = vec2(float(x), float(y));\n          vec3 rnd = hash3(id + neighbor);\n          vec2 crystalPos = neighbor + rnd.xy;\n          \n          float dist = length(f - crystalPos);\n          minDist = min(minDist, dist);\n        }\n      }\n      \n      return 1.0 - smoothstep(0.0, 0.3, minDist);\n    }\n    \n    void main() {\n      vec3 direction = normalize(vPosition);\n      float height = direction.y;\n      \n      // Base gradient - vibrant purple to blue\n      vec3 topColor = vec3(0.4, 0.2, 0.8);\n      vec3 midColor = vec3(0.2, 0.4, 0.9);\n      vec3 bottomColor = vec3(0.1, 0.6, 0.8);\n      \n      vec3 baseColor = mix(bottomColor, midColor, smoothstep(-1.0, 0.0, height));\n      baseColor = mix(baseColor, topColor, smoothstep(0.0, 1.0, height));\n      \n      // Crystal clusters\n      vec2 sphereCoord = direction.xz / (1.0 + abs(height) * 0.5);\n      float crystals = crystalPattern(sphereCoord * 8.0);\n      \n      // Pulsing glow\n      float pulse = sin(time * pulseSpeed) * 0.5 + 0.5;\n      float glow = crystals * crystalGlow * (0.7 + pulse * 0.3);\n      \n      // Crystal colors - vibrant and varied\n      vec3 crystalColors[5];\n      crystalColors[0] = vec3(1.0, 0.3, 0.5); // Pink\n      crystalColors[1] = vec3(0.3, 1.0, 0.8); // Cyan\n      crystalColors[2] = vec3(0.8, 0.5, 1.0); // Purple\n      crystalColors[3] = vec3(0.5, 1.0, 0.3); // Green\n      crystalColors[4] = vec3(1.0, 0.8, 0.3); // Gold\n      \n      // Pick crystal color based on position\n      float colorIndex = hash(floor(sphereCoord * 8.0)) * 5.0;\n      int idx = int(colorIndex);\n      vec3 crystalColor = crystalColors[0];\n      if (idx == 1) crystalColor = crystalColors[1];\n      else if (idx == 2) crystalColor = crystalColors[2];\n      else if (idx == 3) crystalColor = crystalColors[3];\n      else if (idx == 4) crystalColor = crystalColors[4];\n      \n      // Mix crystal glow with base\n      vec3 finalColor = mix(baseColor, crystalColor, glow);\n      \n      // Add ambient glow to entire cave\n      vec3 ambientGlow = vec3(0.3, 0.4, 0.6);\n      finalColor += ambientGlow * 0.3;\n      \n      // Bioluminescent particles\n      float particles = 0.0;\n      for (int i = 0; i < 3; i++) {\n        vec2 pCoord = sphereCoord * (10.0 + float(i) * 5.0) + time * 0.05 * float(i + 1);\n        float p = smoothstep(0.98, 1.0, hash(floor(pCoord)));\n        particles += p;\n      }\n      finalColor += vec3(0.5, 0.8, 1.0) * particles * 0.5;\n      \n      // Ensure brightness\n      finalColor = max(finalColor, vec3(0.2, 0.3, 0.4));\n      \n      gl_FragColor = vec4(finalColor, 1.0);\n    }\n  `\n};"],"names":["crystalCavern"],"mappings":"AAMA,MAAAA,EAAe,CACb,KAAM,iBACN,YAAa,gDACb,OAAQ,wBACR,QAAS,QACT,KAAM,CAAC,UAAW,OAAQ,UAAW,OAAQ,aAAa,EAC1D,KAAM,WAEN,SAAU,CACR,YAAa,CAAE,MAAO,EAAG,EACzB,WAAY,CAAE,MAAO,EAAG,EACxB,WAAY,CAAE,MAAO,CAAG,CAC5B,EAEE,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYd,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAsGlB"}