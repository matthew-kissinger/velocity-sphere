{"version":3,"file":"cyber-tunnel-AyK8TJwZ.js","sources":["../../src/shaders/cyber-tunnel.js"],"sourcesContent":["/**\r\n * Cyber Tunnel Shader\r\n * Dark tunnel walls with flowing data streams\r\n * Creates the feeling of racing through digital infrastructure\r\n */\r\n\r\nimport * as THREE from 'three';\r\n\r\nexport default {\r\n  name: 'cyber-tunnel',\r\n  description: 'Dark tunnel surface with flowing data streams',\r\n  author: 'Circuit Epsilon AI Agent',\r\n  version: '1.0.0',\r\n  tags: ['cyber', 'tunnel', 'data', 'dark', 'underground'],\r\n  performance: 'good',\r\n  \r\n  uniforms: {\r\n    dataColor1: { value: new THREE.Color(0x00ff88) }, // Green data\r\n    dataColor2: { value: new THREE.Color(0x0088ff) }, // Blue data\r\n    wallColor: { value: new THREE.Color(0x050505) }, // Almost black\r\n    streamSpeed: { value: 3.0 },\r\n    streamDensity: { value: 5.0 },\r\n    glowIntensity: { value: 1.5 }\r\n  },\r\n  \r\n  vertexShader: `\r\n    varying vec3 vPosition;\r\n    varying vec3 vNormal;\r\n    varying vec2 vUv;\r\n    varying vec3 vWorldPosition;\r\n    \r\n    void main() {\r\n      vPosition = position;\r\n      vNormal = normalize(normalMatrix * normal);\r\n      vUv = uv;\r\n      \r\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\r\n      vWorldPosition = worldPosition.xyz;\r\n      \r\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    }\r\n  `,\r\n  \r\n  fragmentShader: `\r\n    uniform float time;\r\n    uniform vec3 dataColor1;\r\n    uniform vec3 dataColor2;\r\n    uniform vec3 wallColor;\r\n    uniform float streamSpeed;\r\n    uniform float streamDensity;\r\n    uniform float glowIntensity;\r\n    \r\n    varying vec3 vPosition;\r\n    varying vec3 vNormal;\r\n    varying vec2 vUv;\r\n    varying vec3 vWorldPosition;\r\n    \r\n    float hash(vec2 p) {\r\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\r\n    }\r\n    \r\n    float dataStream(vec2 pos, float offset) {\r\n      float stream = sin(pos.y * streamDensity - time * streamSpeed + offset);\r\n      stream = smoothstep(0.5, 1.0, stream);\r\n      \r\n      // Add binary data effect\r\n      float binary = step(0.5, hash(floor(pos * 20.0 + vec2(0.0, time * streamSpeed))));\r\n      stream *= 0.7 + binary * 0.3;\r\n      \r\n      return stream;\r\n    }\r\n    \r\n    void main() {\r\n      // Base tunnel wall color\r\n      vec3 color = wallColor;\r\n      \r\n      // Create multiple data streams\r\n      vec2 streamPos = vWorldPosition.xz * 0.1;\r\n      \r\n      // Vertical data streams on walls\r\n      float stream1 = dataStream(streamPos, 0.0);\r\n      float stream2 = dataStream(streamPos + vec2(0.5, 0.0), 3.14);\r\n      float stream3 = dataStream(streamPos + vec2(1.0, 0.0), 6.28);\r\n      \r\n      // Combine streams with different colors\r\n      vec3 dataGlow = vec3(0.0);\r\n      dataGlow += dataColor1 * stream1 * 0.8;\r\n      dataGlow += dataColor2 * stream2 * 0.6;\r\n      dataGlow += mix(dataColor1, dataColor2, 0.5) * stream3 * 0.4;\r\n      \r\n      // Add horizontal scan lines\r\n      float scanline = sin(vWorldPosition.y * 50.0 + time * 2.0);\r\n      scanline = smoothstep(0.8, 1.0, scanline) * 0.3;\r\n      dataGlow += mix(dataColor1, dataColor2, 0.5) * scanline;\r\n      \r\n      // Circuit board pattern\r\n      float circuit = 0.0;\r\n      vec2 circuitUV = vUv * 30.0;\r\n      float circuitH = smoothstep(0.48, 0.5, abs(fract(circuitUV.x) - 0.5));\r\n      float circuitV = smoothstep(0.48, 0.5, abs(fract(circuitUV.y) - 0.5));\r\n      circuit = max(circuitH, circuitV) * 0.2;\r\n      \r\n      // Add circuit pattern with data flow\r\n      vec3 circuitColor = mix(dataColor1, dataColor2, sin(time) * 0.5 + 0.5);\r\n      color += circuitColor * circuit;\r\n      \r\n      // Apply data glow\r\n      color += dataGlow * glowIntensity;\r\n      \r\n      // Depth-based fog for tunnel atmosphere\r\n      float depth = length(vWorldPosition - cameraPosition) * 0.01;\r\n      color = mix(color, wallColor * 0.5, smoothstep(0.0, 1.0, depth));\r\n      \r\n      // Ensure minimum visibility\r\n      color = max(color, wallColor * 0.1);\r\n      \r\n      gl_FragColor = vec4(color, 1.0);\r\n    }\r\n  `\r\n};"],"names":["cyberTunnel","THREE.Color"],"mappings":"uCAQA,MAAAA,EAAe,CACb,KAAM,eACN,YAAa,gDACb,OAAQ,2BACR,QAAS,QACT,KAAM,CAAC,QAAS,SAAU,OAAQ,OAAQ,aAAa,EACvD,YAAa,OAEb,SAAU,CACR,WAAY,CAAE,MAAO,IAAIC,EAAY,KAAQ,CAAC,EAC9C,WAAY,CAAE,MAAO,IAAIA,EAAY,KAAQ,CAAC,EAC9C,UAAW,CAAE,MAAO,IAAIA,EAAY,MAAQ,CAAC,EAC7C,YAAa,CAAE,MAAO,CAAG,EACzB,cAAe,CAAE,MAAO,CAAG,EAC3B,cAAe,CAAE,MAAO,GAAG,CAC/B,EAEE,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkBd,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GA4ElB"}