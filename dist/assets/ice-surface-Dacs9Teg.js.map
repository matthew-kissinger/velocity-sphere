{"version":3,"file":"ice-surface-Dacs9Teg.js","sources":["../../src/shaders/ice-surface.js"],"sourcesContent":["/**\n * Ice Surface Shader\n * Slippery ice with frost patterns and crystalline reflections\n * Perfect for arctic/winter themed tracks\n */\n\nimport * as THREE from 'three';\n\nexport default {\n  name: 'ice-surface',\n  description: 'Icy surface with frost crystals and reflective shine',\n  author: 'Circuit Beta AI Agent',\n  version: '1.0.0',\n  tags: ['ice', 'frost', 'arctic', 'winter', 'slippery'],\n  performance: 'medium',\n  \n  uniforms: {\n    iceColor: { value: new THREE.Color(0xb0e0e6) },\n    deepIceColor: { value: new THREE.Color(0x4682b4) },\n    frostColor: { value: new THREE.Color(0xf0ffff) },\n    reflectivity: { value: 0.8 },\n    frostAmount: { value: 0.5 },\n    crackIntensity: { value: 0.3 }\n  },\n  \n  vertexShader: `\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec3 vWorldPosition;\n    \n    void main() {\n      vPosition = position;\n      vNormal = normalize(normalMatrix * normal);\n      vUv = uv;\n      \n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPosition.xyz;\n      \n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  \n  fragmentShader: `\n    uniform float time;\n    uniform vec3 iceColor;\n    uniform vec3 deepIceColor;\n    uniform vec3 frostColor;\n    uniform float reflectivity;\n    uniform float frostAmount;\n    uniform float crackIntensity;\n    uniform vec3 cameraPosition;\n    \n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec3 vWorldPosition;\n    \n    // Hash for random\n    float hash(vec2 p) {\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n    }\n    \n    // Voronoi for ice cracks\n    float voronoi(vec2 p) {\n      vec2 n = floor(p);\n      vec2 f = fract(p);\n      \n      float minDist = 1.0;\n      vec2 minPoint;\n      \n      for(int y = -1; y <= 1; y++) {\n        for(int x = -1; x <= 1; x++) {\n          vec2 neighbor = vec2(float(x), float(y));\n          vec2 point = vec2(hash(n + neighbor), hash(n + neighbor + vec2(17.0, 53.0)));\n          vec2 diff = neighbor + point - f;\n          float dist = length(diff);\n          \n          if(dist < minDist) {\n            minDist = dist;\n            minPoint = point;\n          }\n        }\n      }\n      \n      return minDist;\n    }\n    \n    // Fractal noise for frost\n    float noise(vec2 p) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\n      vec2 u = f * f * (3.0 - 2.0 * f);\n      \n      return mix(mix(hash(i + vec2(0.0, 0.0)), \n                     hash(i + vec2(1.0, 0.0)), u.x),\n                 mix(hash(i + vec2(0.0, 1.0)), \n                     hash(i + vec2(1.0, 1.0)), u.x), u.y);\n    }\n    \n    float fbm(vec2 p) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      \n      for(int i = 0; i < 4; i++) {\n        value += amplitude * noise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n      }\n      \n      return value;\n    }\n    \n    void main() {\n      vec2 uv = vWorldPosition.xz * 0.1;\n      \n      // Ice depth variation\n      float depth = fbm(uv * 2.0) * 0.5 + 0.5;\n      vec3 baseIce = mix(deepIceColor, iceColor, depth);\n      \n      // Ice cracks pattern\n      float cracks = voronoi(uv * 5.0);\n      cracks = 1.0 - smoothstep(0.0, 0.1, cracks);\n      cracks *= crackIntensity;\n      \n      // Smaller crack details\n      float detailCracks = voronoi(uv * 20.0);\n      detailCracks = 1.0 - smoothstep(0.0, 0.05, detailCracks);\n      cracks += detailCracks * 0.3 * crackIntensity;\n      \n      // Frost crystalline patterns\n      float frost = fbm(uv * 10.0);\n      frost = pow(frost, 2.0);\n      \n      // Star-like frost crystals\n      vec2 polarUv = uv * 50.0;\n      float angle = atan(polarUv.y, polarUv.x);\n      float crystals = sin(angle * 6.0) * 0.5 + 0.5;\n      crystals *= sin(angle * 12.0) * 0.5 + 0.5;\n      crystals = pow(crystals, 3.0);\n      crystals *= noise(uv * 100.0);\n      \n      frost = mix(frost, crystals, 0.3);\n      frost *= frostAmount;\n      \n      // Mix ice colors\n      vec3 color = baseIce;\n      color = mix(color, deepIceColor * 0.7, cracks);\n      color = mix(color, frostColor, frost * 0.6);\n      \n      // Calculate reflections\n      vec3 viewDir = normalize(cameraPosition - vWorldPosition);\n      vec3 lightDir = normalize(vec3(0.3, 1.0, 0.5));\n      vec3 halfwayDir = normalize(lightDir + viewDir);\n      \n      // Specular highlights (ice shine)\n      float spec = pow(max(dot(vNormal, halfwayDir), 0.0), 128.0);\n      color += vec3(0.5, 0.7, 0.9) * spec * reflectivity;\n      \n      // Fresnel effect for edge glow\n      float fresnel = pow(1.0 - dot(viewDir, vNormal), 2.0);\n      color += iceColor * fresnel * 0.3 * reflectivity;\n      \n      // Basic lighting\n      float lighting = dot(vNormal, lightDir) * 0.3 + 0.7;\n      color *= lighting;\n      \n      // Add subtle shimmer\n      float shimmer = sin(time * 3.0 + fbm(uv * 5.0) * 10.0) * 0.05 + 0.95;\n      color *= shimmer;\n      \n      // Blue tint in shadows\n      float shadow = 1.0 - lighting;\n      color += deepIceColor * shadow * 0.1;\n      \n      gl_FragColor = vec4(color, 1.0);\n    }\n  `\n};"],"names":["iceSurface","THREE.Color"],"mappings":"uCAQA,MAAAA,EAAe,CACb,KAAM,cACN,YAAa,uDACb,OAAQ,wBACR,QAAS,QACT,KAAM,CAAC,MAAO,QAAS,SAAU,SAAU,UAAU,EACrD,YAAa,SAEb,SAAU,CACR,SAAU,CAAE,MAAO,IAAIC,EAAY,QAAQ,CAAC,EAC5C,aAAc,CAAE,MAAO,IAAIA,EAAY,OAAQ,CAAC,EAChD,WAAY,CAAE,MAAO,IAAIA,EAAY,QAAQ,CAAC,EAC9C,aAAc,CAAE,MAAO,EAAG,EAC1B,YAAa,CAAE,MAAO,EAAG,EACzB,eAAgB,CAAE,MAAO,EAAG,CAChC,EAEE,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkBd,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAuIlB"}