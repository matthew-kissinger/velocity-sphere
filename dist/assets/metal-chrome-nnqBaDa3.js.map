{"version":3,"file":"metal-chrome-nnqBaDa3.js","sources":["../../src/shaders/metal-chrome.js"],"sourcesContent":["/**\n * Metal Chrome Shader\n * Reflective metallic surface with industrial polish\n * Perfect for factory/industrial themed tracks\n */\n\nimport * as THREE from 'three';\n\nexport default {\n  name: 'metal-chrome',\n  description: 'Polished chrome surface with metallic reflections',\n  author: 'Circuit Beta AI Agent',\n  version: '1.0.0',\n  tags: ['metal', 'chrome', 'industrial', 'reflective', 'factory'],\n  performance: 'medium',\n  \n  uniforms: {\n    baseMetalColor: { value: new THREE.Color(0x888888) },\n    highlightColor: { value: new THREE.Color(0xffffff) },\n    rustColor: { value: new THREE.Color(0x8b4513) },\n    reflectivity: { value: 0.9 },\n    roughness: { value: 0.2 },\n    rustAmount: { value: 0.1 }\n  },\n  \n  vertexShader: `\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec3 vWorldPosition;\n    varying vec3 vViewPosition;\n    \n    void main() {\n      vPosition = position;\n      vNormal = normalize(normalMatrix * normal);\n      vUv = uv;\n      \n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPosition.xyz;\n      \n      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n      vViewPosition = -mvPosition.xyz;\n      \n      gl_Position = projectionMatrix * mvPosition;\n    }\n  `,\n  \n  fragmentShader: `\n    uniform float time;\n    uniform vec3 baseMetalColor;\n    uniform vec3 highlightColor;\n    uniform vec3 rustColor;\n    uniform float reflectivity;\n    uniform float roughness;\n    uniform float rustAmount;\n    uniform vec3 cameraPosition;\n    \n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec3 vWorldPosition;\n    varying vec3 vViewPosition;\n    \n    // Hash for procedural patterns\n    float hash(vec2 p) {\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n    }\n    \n    float noise(vec2 p) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\n      vec2 u = f * f * (3.0 - 2.0 * f);\n      \n      return mix(mix(hash(i + vec2(0.0, 0.0)), \n                     hash(i + vec2(1.0, 0.0)), u.x),\n                 mix(hash(i + vec2(0.0, 1.0)), \n                     hash(i + vec2(1.0, 1.0)), u.x), u.y);\n    }\n    \n    // Voronoi for surface imperfections\n    float voronoi(vec2 p) {\n      vec2 n = floor(p);\n      vec2 f = fract(p);\n      \n      float minDist = 1.0;\n      \n      for(int y = -1; y <= 1; y++) {\n        for(int x = -1; x <= 1; x++) {\n          vec2 neighbor = vec2(float(x), float(y));\n          vec2 point = vec2(hash(n + neighbor), hash(n + neighbor + vec2(17.0, 31.0)));\n          vec2 diff = neighbor + point - f;\n          float dist = length(diff);\n          minDist = min(minDist, dist);\n        }\n      }\n      \n      return minDist;\n    }\n    \n    float fbm(vec2 p) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      \n      for(int i = 0; i < 4; i++) {\n        value += amplitude * noise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n      }\n      \n      return value;\n    }\n    \n    void main() {\n      vec2 uv = vWorldPosition.xz * 0.1;\n      \n      // Metal base with subtle variations\n      vec3 metalColor = baseMetalColor;\n      \n      // Add brushed metal texture\n      float brushed = sin(uv.x * 200.0) * 0.02 + sin(uv.y * 200.0) * 0.02;\n      brushed += sin(uv.x * 500.0 + uv.y * 500.0) * 0.01;\n      metalColor += vec3(brushed);\n      \n      // Surface imperfections and scratches\n      float scratches = 1.0 - smoothstep(0.0, 0.02, voronoi(uv * 50.0));\n      scratches *= 0.3;\n      metalColor *= 1.0 - scratches * 0.5;\n      \n      // Rust patches\n      float rust = fbm(uv * 10.0);\n      rust = smoothstep(0.5, 0.7, rust);\n      rust *= rustAmount;\n      \n      // Rust spreads from edges and low areas\n      float edgeFactor = 1.0 - abs(vNormal.y);\n      rust *= 1.0 + edgeFactor * 2.0;\n      rust = clamp(rust, 0.0, 1.0);\n      \n      // Mix in rust color\n      metalColor = mix(metalColor, rustColor, rust);\n      \n      // Calculate reflections\n      vec3 viewDir = normalize(cameraPosition - vWorldPosition);\n      vec3 lightDir = normalize(vec3(1.0, 1.0, 0.5));\n      vec3 halfwayDir = normalize(lightDir + viewDir);\n      \n      // Anisotropic highlights for brushed metal look\n      float NdotH = dot(vNormal, halfwayDir);\n      float anisotropic = pow(NdotH, 128.0 / (1.0 + roughness * 5.0));\n      \n      // Multiple light sources for industrial feel\n      vec3 lightDir2 = normalize(vec3(-0.5, 0.5, -1.0));\n      vec3 halfwayDir2 = normalize(lightDir2 + viewDir);\n      float NdotH2 = dot(vNormal, halfwayDir2);\n      float anisotropic2 = pow(max(NdotH2, 0.0), 64.0 / (1.0 + roughness * 5.0));\n      \n      // Combine highlights\n      vec3 specular = highlightColor * (anisotropic + anisotropic2 * 0.5) * reflectivity;\n      specular *= 1.0 - rust; // Rust doesn't reflect\n      \n      // Environment reflection simulation\n      float fresnel = pow(1.0 - dot(viewDir, vNormal), 2.0);\n      vec3 envReflection = mix(baseMetalColor * 1.2, highlightColor * 0.8, fresnel);\n      envReflection *= reflectivity * 0.3 * (1.0 - rust);\n      \n      // Combine all components\n      vec3 finalColor = metalColor + specular + envReflection;\n      \n      // Industrial lighting\n      float lighting = dot(vNormal, lightDir) * 0.5 + 0.5;\n      finalColor *= lighting;\n      \n      // Add subtle time-based shimmer for polished areas\n      float shimmer = sin(time * 2.0 + fbm(uv * 2.0) * 5.0) * 0.02 + 0.98;\n      finalColor *= shimmer * (1.0 - rust * 0.5);\n      \n      gl_FragColor = vec4(finalColor, 1.0);\n    }\n  `\n};"],"names":["metalChrome","THREE.Color"],"mappings":"uCAQA,MAAAA,EAAe,CACb,KAAM,eACN,YAAa,oDACb,OAAQ,wBACR,QAAS,QACT,KAAM,CAAC,QAAS,SAAU,aAAc,aAAc,SAAS,EAC/D,YAAa,SAEb,SAAU,CACR,eAAgB,CAAE,MAAO,IAAIC,EAAY,OAAQ,CAAC,EAClD,eAAgB,CAAE,MAAO,IAAIA,EAAY,QAAQ,CAAC,EAClD,UAAW,CAAE,MAAO,IAAIA,EAAY,OAAQ,CAAC,EAC7C,aAAc,CAAE,MAAO,EAAG,EAC1B,UAAW,CAAE,MAAO,EAAG,EACvB,WAAY,CAAE,MAAO,EAAG,CAC5B,EAEE,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAsBd,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAoIlB"}