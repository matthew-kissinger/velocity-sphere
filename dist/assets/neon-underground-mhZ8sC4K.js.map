{"version":3,"file":"neon-underground-mhZ8sC4K.js","sources":["../../src/skyboxes/neon-underground.js"],"sourcesContent":["/**\n * Neon Underground Skybox\n * Sleek dark underground aesthetic with subtle neon accents\n * Perfect for underground racing circuits\n */\n\nexport default {\n  name: 'neon-underground',\n  description: 'Dark underground atmosphere with subtle neon lighting',\n  author: 'Velocity Sphere Team',\n  version: '1.0.0',\n  tags: ['neon', 'underground', 'dark', 'sleek', 'circuit-epsilon'],\n  mood: 'cyberpunk',\n  \n  uniforms: {\n    neonIntensity: { value: 0.3 },\n    fogDensity: { value: 0.6 },\n    glowPulse: { value: 1.0 }\n  },\n  \n  vertexShader: `\n    varying vec3 vWorldPosition;\n    varying vec3 vPosition;\n    \n    void main() {\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPosition.xyz;\n      vPosition = position;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  \n  fragmentShader: `\n    uniform float time;\n    uniform float neonIntensity;\n    uniform float fogDensity;\n    uniform float glowPulse;\n    \n    varying vec3 vWorldPosition;\n    varying vec3 vPosition;\n    \n    float hash(vec2 p) {\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n    }\n    \n    float noise(vec2 p) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\n      f = f * f * (3.0 - 2.0 * f);\n      \n      float a = hash(i);\n      float b = hash(i + vec2(1.0, 0.0));\n      float c = hash(i + vec2(0.0, 1.0));\n      float d = hash(i + vec2(1.0, 1.0));\n      \n      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n    }\n    \n    void main() {\n      vec3 direction = normalize(vWorldPosition);\n      float y = direction.y;\n      \n      // Base colors - very dark with subtle color variation\n      vec3 deepBlack = vec3(0.01, 0.01, 0.02);\n      vec3 darkBlue = vec3(0.02, 0.03, 0.06);\n      vec3 darkPurple = vec3(0.04, 0.02, 0.05);\n      \n      // Gradient based on height\n      vec3 color;\n      if (y > 0.1) {\n        // Ceiling area - deepest black\n        color = deepBlack;\n        \n        // Very subtle grid pattern on ceiling\n        float grid = sin(direction.x * 50.0) * sin(direction.z * 50.0);\n        grid = smoothstep(0.98, 1.0, grid);\n        color += vec3(0.02, 0.02, 0.03) * grid;\n      } else if (y > -0.1) {\n        // Mid section - gradient\n        float factor = (y + 0.1) / 0.2;\n        color = mix(darkPurple, darkBlue, factor);\n      } else {\n        // Floor area - slightly lighter\n        color = darkPurple + vec3(0.01);\n        \n        // Subtle floor reflection\n        float reflection = smoothstep(-1.0, -0.5, y);\n        color += vec3(0.01, 0.0, 0.02) * reflection;\n      }\n      \n      // Distant neon light sources\n      float neonLights = 0.0;\n      \n      // Horizontal neon strips\n      for (float i = 0.0; i < 3.0; i++) {\n        float height = -0.3 + i * 0.3;\n        float strip = 1.0 - abs(y - height) * 20.0;\n        strip = smoothstep(0.0, 1.0, strip);\n        \n        // Alternating colors\n        vec3 stripColor = (mod(i, 2.0) < 1.0) ? \n          vec3(0.1, 0.4, 0.8) : vec3(0.8, 0.1, 0.4);\n        \n        // Add pulse\n        float pulse = sin(time * glowPulse + i * 2.0) * 0.3 + 0.7;\n        color += stripColor * strip * neonIntensity * pulse * 0.5;\n      }\n      \n      // Vertical support pillars with neon\n      float pillarPattern = sin(direction.x * 20.0) * sin(direction.z * 20.0);\n      pillarPattern = smoothstep(0.95, 1.0, pillarPattern);\n      vec3 pillarGlow = vec3(0.0, 0.6, 0.8) * pillarPattern * neonIntensity;\n      color += pillarGlow * (1.0 - abs(y)) * 0.3;\n      \n      // Atmospheric fog\n      float fog = noise(direction.xz * 5.0 + time * 0.05);\n      fog = smoothstep(0.4, 0.8, fog) * fogDensity;\n      color = mix(color, darkBlue * 0.5, fog * 0.2);\n      \n      // Distant tunnel glow\n      float tunnelGlow = 1.0 - length(direction.xz);\n      tunnelGlow = pow(tunnelGlow, 4.0);\n      color += vec3(0.0, 0.2, 0.4) * tunnelGlow * 0.1;\n      \n      // Very subtle animated scan lines\n      float scanline = sin(direction.y * 100.0 + time * 2.0);\n      scanline = smoothstep(0.99, 1.0, scanline);\n      color += vec3(0.0, 0.05, 0.08) * scanline * 0.3;\n      \n      // Ensure visibility but maintain dark aesthetic\n      color = max(color, deepBlack);\n      color = min(color, vec3(0.2)); // Cap brightness\n      \n      gl_FragColor = vec4(color, 1.0);\n    }\n  `\n};"],"names":["neonUnderground"],"mappings":"AAMA,MAAAA,EAAe,CACb,KAAM,mBACN,YAAa,wDACb,OAAQ,uBACR,QAAS,QACT,KAAM,CAAC,OAAQ,cAAe,OAAQ,QAAS,iBAAiB,EAChE,KAAM,YAEN,SAAU,CACR,cAAe,CAAE,MAAO,EAAG,EAC3B,WAAY,CAAE,MAAO,EAAG,EACxB,UAAW,CAAE,MAAO,CAAG,CAC3B,EAEE,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYd,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAwGlB"}