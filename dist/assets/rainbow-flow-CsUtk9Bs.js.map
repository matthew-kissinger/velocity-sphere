{"version":3,"file":"rainbow-flow-CsUtk9Bs.js","sources":["../../src/shaders/rainbow-flow.js"],"sourcesContent":["/**\r\n * Rainbow Flow Shader\r\n * Classic rainbow track shader with flowing colors\r\n * Perfect for Circuit Alpha tracks\r\n */\r\n\r\nexport default {\r\n  name: 'rainbow-flow',\r\n  description: 'Classic rainbow track with flowing color transitions',\r\n  author: 'Velocity Sphere Team',\r\n  version: '1.0.0',\r\n  tags: ['rainbow', 'flow', 'classic', 'circuit-alpha'],\r\n  performance: 'good',\r\n  \r\n  uniforms: {\r\n    colorSpeed: { value: 1.0 },\r\n    flowSpeed: { value: 0.5 },\r\n    intensity: { value: 1.0 },\r\n    saturation: { value: 0.8 }\r\n  },\r\n  \r\n  vertexShader: `\r\n    varying vec3 vPosition;\r\n    varying vec3 vNormal;\r\n    varying vec2 vUv;\r\n    varying vec3 vWorldPosition;\r\n    \r\n    void main() {\r\n      vPosition = position;\r\n      vNormal = normalize(normalMatrix * normal);\r\n      vUv = uv;\r\n      \r\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\r\n      vWorldPosition = worldPosition.xyz;\r\n      \r\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n    }\r\n  `,\r\n  \r\n  fragmentShader: `\r\n    uniform float time;\r\n    uniform float colorSpeed;\r\n    uniform float flowSpeed;\r\n    uniform float intensity;\r\n    uniform float saturation;\r\n    \r\n    varying vec3 vPosition;\r\n    varying vec3 vNormal;\r\n    varying vec2 vUv;\r\n    varying vec3 vWorldPosition;\r\n    \r\n    vec3 hsv2rgb(vec3 c) {\r\n      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\r\n      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\r\n      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\r\n    }\r\n    \r\n    void main() {\r\n      // Create flowing rainbow based on world position and time\r\n      float hue = fract((vWorldPosition.x + vWorldPosition.z) * 0.05 + time * flowSpeed);\r\n      hue = fract(hue + time * colorSpeed * 0.1);\r\n      \r\n      // Add some noise for visual interest\r\n      float noise = sin(vWorldPosition.x * 0.1) * sin(vWorldPosition.z * 0.1) * 0.1;\r\n      hue += noise;\r\n      \r\n      // Convert HSV to RGB\r\n      vec3 color = hsv2rgb(vec3(hue, saturation, intensity));\r\n      \r\n      // Add some lighting based on normal\r\n      float lighting = dot(vNormal, normalize(vec3(1.0, 1.0, 1.0))) * 0.5 + 0.5;\r\n      color *= lighting;\r\n      \r\n      // Add subtle glow effect\r\n      float glow = 1.0 + sin(time * 2.0 + hue * 6.28) * 0.1;\r\n      color *= glow;\r\n      \r\n      gl_FragColor = vec4(color, 1.0);\r\n    }\r\n  `\r\n};"],"names":["rainbowFlow"],"mappings":"AAMA,MAAAA,EAAe,CACb,KAAM,eACN,YAAa,uDACb,OAAQ,uBACR,QAAS,QACT,KAAM,CAAC,UAAW,OAAQ,UAAW,eAAe,EACpD,YAAa,OAEb,SAAU,CACR,WAAY,CAAE,MAAO,CAAG,EACxB,UAAW,CAAE,MAAO,EAAG,EACvB,UAAW,CAAE,MAAO,CAAG,EACvB,WAAY,CAAE,MAAO,EAAG,CAC5B,EAEE,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkBd,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAyClB"}