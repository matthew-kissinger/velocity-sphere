{"version":3,"file":"storm-clouds-6l7kfk3L.js","sources":["../../src/skyboxes/storm-clouds.js"],"sourcesContent":["/**\n * Storm Clouds Skybox\n * Dark dramatic storm atmosphere with lightning flashes\n * High contrast with storm-electric shader for visibility\n */\n\nexport default {\n  name: 'storm-clouds',\n  description: 'Dramatic storm clouds with lightning and turbulent skies',\n  author: 'Circuit Beta Upgrade Team',\n  version: '1.0.0',\n  tags: ['storm', 'clouds', 'lightning', 'dramatic', 'weather'],\n  mood: 'intense',\n  \n  uniforms: {\n    stormIntensity: { value: 0.8 },\n    lightningFrequency: { value: 0.05 },\n    cloudSpeed: { value: 0.4 }\n  },\n  \n  vertexShader: `\n    varying vec3 vWorldPosition;\n    varying vec3 vPosition;\n    \n    void main() {\n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPosition.xyz;\n      vPosition = position;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  \n  fragmentShader: `\n    uniform float time;\n    uniform float stormIntensity;\n    uniform float lightningFrequency;\n    uniform float cloudSpeed;\n    \n    varying vec3 vWorldPosition;\n    varying vec3 vPosition;\n    \n    // Hash for randomness\n    float hash(float n) {\n      return fract(sin(n) * 43758.5453123);\n    }\n    \n    float hash2(vec2 p) {\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n    }\n    \n    // Noise functions for clouds\n    float noise(vec2 p) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\n      vec2 u = f * f * (3.0 - 2.0 * f);\n      \n      return mix(\n        mix(hash2(i + vec2(0.0, 0.0)), hash2(i + vec2(1.0, 0.0)), u.x),\n        mix(hash2(i + vec2(0.0, 1.0)), hash2(i + vec2(1.0, 1.0)), u.x),\n        u.y\n      );\n    }\n    \n    float fbm(vec2 p) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      float frequency = 1.0;\n      \n      for (int i = 0; i < 5; i++) {\n        value += amplitude * noise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n      }\n      \n      return value;\n    }\n    \n    // Storm cloud generation\n    float stormClouds(vec2 p, float t) {\n      // Animate clouds\n      p += vec2(t * cloudSpeed * 0.1, t * cloudSpeed * 0.05);\n      \n      // Multiple layers for depth\n      float clouds = 0.0;\n      clouds += fbm(p * 2.0) * 0.5;\n      clouds += fbm(p * 4.0 + vec2(100.0)) * 0.3;\n      clouds += fbm(p * 8.0 + vec2(200.0)) * 0.2;\n      \n      // Create dramatic cloud shapes\n      clouds = pow(clouds, 1.5) * stormIntensity;\n      \n      return clouds;\n    }\n    \n    void main() {\n      vec3 direction = normalize(vPosition);\n      float height = direction.y;\n      \n      // Base sky colors - dark and moody\n      vec3 skyTop = vec3(0.15, 0.15, 0.2);\n      vec3 skyMid = vec3(0.1, 0.1, 0.15);\n      vec3 skyBottom = vec3(0.05, 0.05, 0.1);\n      \n      // Sky gradient\n      vec3 skyColor = mix(skyBottom, skyMid, smoothstep(-1.0, 0.0, height));\n      skyColor = mix(skyColor, skyTop, smoothstep(0.0, 1.0, height));\n      \n      // Storm clouds\n      vec2 cloudCoord = direction.xz / (1.0 + abs(height) * 0.5);\n      float cloudDensity = stormClouds(cloudCoord * 3.0, time);\n      \n      // Cloud colors - dark grays and blues\n      vec3 cloudColorDark = vec3(0.02, 0.02, 0.03);\n      vec3 cloudColorLight = vec3(0.2, 0.22, 0.25);\n      vec3 cloudColor = mix(cloudColorLight, cloudColorDark, cloudDensity);\n      \n      // Mix clouds with sky\n      float cloudCoverage = smoothstep(0.2, 0.8, cloudDensity);\n      skyColor = mix(skyColor, cloudColor, cloudCoverage);\n      \n      // Lightning effect\n      float lightningTime = floor(time * 3.0);\n      float lightningRandom = hash(lightningTime);\n      \n      if (lightningRandom < lightningFrequency) {\n        float lightningPhase = fract(time * 3.0);\n        float lightningIntensity = exp(-lightningPhase * 8.0);\n        \n        // Lightning flash location\n        vec2 lightningPos = vec2(\n          hash(lightningTime + 0.1) * 2.0 - 1.0,\n          hash(lightningTime + 0.2) * 0.5 - 0.25\n        );\n        \n        float distToLightning = length(direction.xz - lightningPos);\n        float lightningGlow = exp(-distToLightning * 2.0) * lightningIntensity;\n        \n        // Flash color - bright blue-white\n        vec3 lightningColor = vec3(0.8, 0.85, 1.0);\n        skyColor = mix(skyColor, lightningColor, lightningGlow * 0.7);\n        \n        // Ambient illumination from lightning\n        skyColor += lightningColor * lightningIntensity * 0.1;\n      }\n      \n      // Add some blue ambient light for visibility\n      vec3 ambientLight = vec3(0.1, 0.15, 0.25);\n      skyColor = max(skyColor, ambientLight * (1.0 - cloudCoverage * 0.5));\n      \n      // Fog at horizon for depth\n      float horizonFog = 1.0 - abs(height);\n      vec3 fogColor = vec3(0.15, 0.17, 0.2);\n      skyColor = mix(skyColor, fogColor, horizonFog * 0.3);\n      \n      gl_FragColor = vec4(skyColor, 1.0);\n    }\n  `\n};"],"names":["stormClouds"],"mappings":"AAMA,MAAAA,EAAe,CACb,KAAM,eACN,YAAa,2DACb,OAAQ,4BACR,QAAS,QACT,KAAM,CAAC,QAAS,SAAU,YAAa,WAAY,SAAS,EAC5D,KAAM,UAEN,SAAU,CACR,eAAgB,CAAE,MAAO,EAAG,EAC5B,mBAAoB,CAAE,MAAO,GAAI,EACjC,WAAY,CAAE,MAAO,EAAG,CAC5B,EAEE,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYd,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GA6HlB"}