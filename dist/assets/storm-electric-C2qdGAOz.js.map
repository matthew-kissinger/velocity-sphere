{"version":3,"file":"storm-electric-C2qdGAOz.js","sources":["../../src/shaders/storm-electric.js"],"sourcesContent":["/**\n * Storm Electric Shader\n * Dynamic storm surface with lightning and electric effects\n * Perfect for storm/weather themed tracks\n */\n\nimport * as THREE from 'three';\n\nexport default {\n  name: 'storm-electric',\n  description: 'Electric storm surface with lightning strikes and energy',\n  author: 'Circuit Beta AI Agent',\n  version: '1.0.0',\n  tags: ['storm', 'electric', 'lightning', 'weather', 'energy'],\n  performance: 'medium',\n  \n  uniforms: {\n    stormColor: { value: new THREE.Color(0x1a1a2e) },\n    lightningColor: { value: new THREE.Color(0x87ceeb) },\n    energyColor: { value: new THREE.Color(0x4169e1) },\n    stormIntensity: { value: 0.8 },\n    lightningFrequency: { value: 0.3 },\n    electricCharge: { value: 0.6 }\n  },\n  \n  vertexShader: `\n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec3 vWorldPosition;\n    \n    void main() {\n      vPosition = position;\n      vNormal = normalize(normalMatrix * normal);\n      vUv = uv;\n      \n      vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n      vWorldPosition = worldPosition.xyz;\n      \n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  \n  fragmentShader: `\n    uniform float time;\n    uniform vec3 stormColor;\n    uniform vec3 lightningColor;\n    uniform vec3 energyColor;\n    uniform float stormIntensity;\n    uniform float lightningFrequency;\n    uniform float electricCharge;\n    \n    varying vec3 vPosition;\n    varying vec3 vNormal;\n    varying vec2 vUv;\n    varying vec3 vWorldPosition;\n    \n    // Random hash\n    float hash(vec2 p) {\n      return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n    }\n    \n    float hash3(vec3 p) {\n      return fract(sin(dot(p, vec3(127.1, 311.7, 543.21))) * 43758.5453123);\n    }\n    \n    // Noise for storm patterns\n    float noise(vec2 p) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\n      vec2 u = f * f * (3.0 - 2.0 * f);\n      \n      return mix(mix(hash(i + vec2(0.0, 0.0)), \n                     hash(i + vec2(1.0, 0.0)), u.x),\n                 mix(hash(i + vec2(0.0, 1.0)), \n                     hash(i + vec2(1.0, 1.0)), u.x), u.y);\n    }\n    \n    float fbm(vec2 p) {\n      float value = 0.0;\n      float amplitude = 0.5;\n      \n      for(int i = 0; i < 5; i++) {\n        value += amplitude * noise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n      }\n      \n      return value;\n    }\n    \n    // Lightning bolt pattern\n    float lightning(vec2 p, float seed) {\n      float bolt = 0.0;\n      vec2 dir = vec2(0.0, 1.0);\n      \n      for(int i = 0; i < 8; i++) {\n        float offset = hash(vec2(float(i), seed)) - 0.5;\n        p.x += offset * 0.1;\n        \n        float dist = abs(p.x);\n        float branch = exp(-dist * 50.0);\n        bolt = max(bolt, branch);\n        \n        p.y -= 0.1;\n      }\n      \n      return bolt;\n    }\n    \n    void main() {\n      vec2 uv = vWorldPosition.xz * 0.1;\n      \n      // Storm surface base\n      float stormPattern = fbm(uv * 2.0 + time * 0.2) * stormIntensity;\n      vec3 baseColor = mix(stormColor, stormColor * 1.5, stormPattern);\n      \n      // Electric charge buildup areas\n      float chargePattern = fbm(uv * 5.0 - time * 0.3);\n      chargePattern = smoothstep(0.5, 0.8, chargePattern);\n      vec3 chargedAreas = mix(baseColor, energyColor, chargePattern * electricCharge);\n      \n      // Lightning strikes\n      float lightningTime = floor(time * lightningFrequency);\n      float lightningPhase = fract(time * lightningFrequency);\n      \n      vec3 color = chargedAreas;\n      \n      // Generate multiple lightning bolts\n      for(int i = 0; i < 3; i++) {\n        float seed = lightningTime + float(i) * 13.7;\n        vec2 boltOrigin = vec2(\n          hash(vec2(seed, seed * 2.0)) * 2.0 - 1.0,\n          hash(vec2(seed * 3.0, seed * 4.0)) * 2.0 - 1.0\n        ) * 10.0;\n        \n        vec2 boltUV = uv - boltOrigin;\n        float bolt = lightning(boltUV, seed);\n        \n        // Lightning flash timing\n        float flash = exp(-lightningPhase * 5.0);\n        bolt *= flash;\n        \n        // Add bolt to color\n        color += lightningColor * bolt * 2.0;\n      }\n      \n      // Electric arcs between charged areas\n      float arcNoise = noise(uv * 20.0 + time * 5.0);\n      float arcs = smoothstep(0.9, 0.95, arcNoise) * chargePattern;\n      color += energyColor * arcs * 0.5;\n      \n      // Pulsing energy veins\n      float veins = sin(uv.x * 30.0 + time * 3.0) * sin(uv.y * 30.0 - time * 2.0);\n      veins = smoothstep(0.5, 0.8, veins) * 0.3;\n      color += energyColor * veins * electricCharge;\n      \n      // Storm turbulence\n      float turbulence = fbm(uv * 10.0 + time * 0.5);\n      turbulence = pow(turbulence, 2.0);\n      color = mix(color, stormColor * 0.5, turbulence * 0.3);\n      \n      // Apply lighting\n      vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n      float lighting = dot(vNormal, lightDir) * 0.3 + 0.7;\n      color *= lighting;\n      \n      // Electric glow based on charge\n      float glow = chargePattern * sin(time * 10.0) * 0.2 + 0.8;\n      color *= glow;\n      \n      // Add corona discharge effect at edges\n      float edge = 1.0 - abs(dot(vNormal, vec3(0.0, 1.0, 0.0)));\n      color += energyColor * edge * 0.2 * electricCharge;\n      \n      gl_FragColor = vec4(color, 1.0);\n    }\n  `\n};"],"names":["stormElectric","THREE.Color"],"mappings":"uCAQA,MAAAA,EAAe,CACb,KAAM,iBACN,YAAa,2DACb,OAAQ,wBACR,QAAS,QACT,KAAM,CAAC,QAAS,WAAY,YAAa,UAAW,QAAQ,EAC5D,YAAa,SAEb,SAAU,CACR,WAAY,CAAE,MAAO,IAAIC,EAAY,OAAQ,CAAC,EAC9C,eAAgB,CAAE,MAAO,IAAIA,EAAY,OAAQ,CAAC,EAClD,YAAa,CAAE,MAAO,IAAIA,EAAY,OAAQ,CAAC,EAC/C,eAAgB,CAAE,MAAO,EAAG,EAC5B,mBAAoB,CAAE,MAAO,EAAG,EAChC,eAAgB,CAAE,MAAO,EAAG,CAChC,EAEE,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAkBd,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAuIlB"}